<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<head>
    <th:block th:replace="~{fragments/common-head :: head-elements(pageTitle=${hierarchy.id != null ? '역할 계층 수정' : '역할 계층 등록'})}"></th:block>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
    <link rel="stylesheet" th:href="@{/css/role-hierarchy.css}">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        /* HTML 고유 스타일만 유지 (CSS 파일로 이동할 수 없는 것들) */
        #mermaid-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="flex flex-col min-h-screen font-sans">

<div th:insert="~{fragments/header :: header}"></div>
<div id="toast-container" class="fixed top-5 right-5 z-50"></div>
<div id="tooltip" class="tooltip"></div>

<div class="flex flex-1">
    <aside th:insert="~{fragments/admin-menu :: menu}"></aside>

    <main class="flex-1 p-6 md:p-10">
        <div class="dark-card p-6 rounded-xl">
            <div class="text-center mb-6">
                <h2 class="text-3xl font-bold text-gradient" th:text="${hierarchy.id != null ? '역할 계층 수정' : '새 역할 계층 등록'}"></h2>
                <p class="text-dark-muted mt-2">역할 간의 상하 관계를 시각적으로 정의하고 관리합니다</p>
            </div>

            <form id="hierarchyForm" method="post" th:object="${hierarchy}" class="space-y-6">
                <input type="hidden" th:field="*{id}" th:if="${hierarchy.id != null}" />
                <input type="hidden" id="hierarchyString" th:field="*{hierarchyString}" />

                <!-- 설명 입력 -->
                <div>
                    <label for="description" class="dark-label">계층 설명:</label>
                    <input type="text" id="description" th:field="*{description}"
                           class="dark-input"
                           placeholder="예: 기본 조직 계층 구조" required />
                </div>

                <!-- 메인 편집 영역: 3단 구조 -->
                <div class="grid grid-cols-12 gap-4">
                    <!-- 왼쪽: 역할 팔레트 -->
                    <div class="col-span-3">
                        <h3 class="text-lg font-bold text-slate-200 mb-3">역할 목록</h3>
                        <div class="role-palette">
                            <!-- 그룹별 역할 표시 -->
                            <div th:each="group : ${groupsWithRoles}" class="group-section">
                                <div class="group-header">
                                    <i class="fas fa-users mr-2"></i>
                                    <span th:text="${group.groupName}"></span>
                                </div>
                                <div th:each="role : ${group.roles}"
                                     class="role-item"
                                     th:data-role="${role.roleName}"
                                     th:data-desc="${role.roleDesc}"
                                     onmouseover="showTooltip(event, this)"
                                     onmouseout="hideTooltip()">
                                    <div class="role-item-name" th:text="${role.roleName}"></div>
                                    <div class="role-item-desc" th:text="${role.roleDesc}"></div>
                                    <div class="mt-1">
                                        <span th:each="perm : ${role.permissions}"
                                              class="permission-tag"
                                              th:text="${perm}"></span>
                                    </div>
                                </div>
                            </div>

                            <!-- 그룹 미지정 역할 -->
                            <div th:if="${!#lists.isEmpty(ungroupedRoles)}" class="group-section">
                                <div class="group-header">
                                    <i class="fas fa-user mr-2"></i>
                                    <span>그룹 미지정</span>
                                </div>
                                <div th:each="role : ${ungroupedRoles}"
                                     class="role-item"
                                     th:data-role="${role.roleName}"
                                     th:data-desc="${role.roleDesc}">
                                    <div class="role-item-name" th:text="${role.roleName}"></div>
                                    <div class="role-item-desc" th:text="${role.roleDesc}"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 중앙: 시각화 캔버스 -->
                    <div class="col-span-5">
                        <h3 class="text-lg font-bold text-slate-200 mb-3">계층 구조 시각화</h3>
                        <div class="hierarchy-visualization">
                            <div id="mermaid-container" style="width: 100%; height: 100%;">
                                <div id="mermaid-diagram" class="mermaid">
                                    graph TD
                                    A[역할 관계를 설정하면<br/>여기에 시각화됩니다]
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 오른쪽: 관계 편집기 -->
                    <div class="col-span-4">
                        <h3 class="text-lg font-bold text-slate-200 mb-3">관계 편집</h3>

                        <!-- 검증 메시지 영역 -->
                        <div id="validation-error" class="validation-error"></div>
                        <div id="validation-warning" class="validation-warning"></div>

                        <div id="hierarchy-rows-container" class="space-y-3">
                            <div th:each="pair, stat : ${hierarchyPairs}" class="relation-row">
                                <div class="grid grid-cols-12 gap-3 items-center">
                                    <div class="col-span-5">
                                        <div class="modern-select-wrapper">
                                            <select class="parent-role modern-select" onchange="validateAndUpdate()">
                                                <option value="">상위 역할 선택</option>
                                                <optgroup th:each="group : ${groupsWithRoles}" th:label="${group.groupName}">
                                                    <option th:each="role : ${group.roles}"
                                                            th:value="${role.roleName}"
                                                            th:text="${role.roleDesc}"
                                                            th:data-subtext="${role.roleName}"
                                                            th:selected="${role.roleName == pair.parentRole}"></option>
                                                </optgroup>
                                                <optgroup th:if="${!#lists.isEmpty(ungroupedRoles)}" label="그룹 미지정">
                                                    <option th:each="role : ${ungroupedRoles}"
                                                            th:value="${role.roleName}"
                                                            th:text="${role.roleDesc}"
                                                            th:data-subtext="${role.roleName}"
                                                            th:selected="${role.roleName == pair.parentRole}"></option>
                                                </optgroup>
                                            </select>
                                            <div class="select-arrow">
                                                <i class="fas fa-chevron-down"></i>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-span-2 text-center">
                                        <div class="relation-arrow-container">
                                            <div class="arrow-line"></div>
                                            <i class="fas fa-chevron-right relation-icon"></i>
                                        </div>
                                    </div>
                                    <div class="col-span-5">
                                        <div class="modern-select-wrapper">
                                            <select class="child-role modern-select" onchange="validateAndUpdate()">
                                                <option value="">하위 역할 선택</option>
                                                <optgroup th:each="group : ${groupsWithRoles}" th:label="${group.groupName}">
                                                    <option th:each="role : ${group.roles}"
                                                            th:value="${role.roleName}"
                                                            th:text="${role.roleDesc}"
                                                            th:data-subtext="${role.roleName}"
                                                            th:selected="${role.roleName == pair.childRole}"></option>
                                                </optgroup>
                                                <optgroup th:if="${!#lists.isEmpty(ungroupedRoles)}" label="그룹 미지정">
                                                    <option th:each="role : ${ungroupedRoles}"
                                                            th:value="${role.roleName}"
                                                            th:text="${role.roleDesc}"
                                                            th:data-subtext="${role.roleName}"
                                                            th:selected="${role.roleName == pair.childRole}"></option>
                                                </optgroup>
                                            </select>
                                            <div class="select-arrow">
                                                <i class="fas fa-chevron-down"></i>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button type="button" onclick="removeRow(this)"
                                        class="mt-3 delete-btn">
                                    <i class="fas fa-trash-alt mr-1"></i> 관계 삭제
                                </button>
                            </div>
                        </div>

                        <button type="button" id="add-row-btn"
                                class="mt-3 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-medium transition-all duration-200">
                            <i class="fas fa-plus mr-1"></i> 관계 추가
                        </button>
                    </div>
                </div>

                <!-- 결과 미리보기 -->
                <div class="mt-6">
                    <h3 class="text-lg font-bold text-slate-200 mb-3">최종 계층 문자열 미리보기</h3>
                    <div id="result-preview" class="result-preview">
                        계층 관계를 설정하면 여기에 결과가 표시됩니다.
                    </div>
                </div>

                <!-- 활성화 옵션 -->
                <div class="flex items-center">
                    <input type="checkbox" id="isActive" th:field="*{isActive}" class="dark-checkbox" />
                    <label for="isActive" class="ml-2 block text-sm text-slate-200">
                        이 계층을 활성화합니다 (기존 활성 계층은 자동으로 비활성화됩니다)
                    </label>
                </div>

                <!-- 제출 버튼 -->
                <div class="pt-4 flex gap-4">
                    <button type="button" onclick="showConfirmDialog()"
                            class="flex-1 dark-btn-primary">
                        <i class="fas fa-save mr-2"></i>
                        <span th:text="${hierarchy.id != null ? '계층 수정' : '계층 등록'}"></span>
                    </button>
                    <a th:href="@{/admin/role-hierarchies}"
                       class="flex-1 text-center py-3 px-4 rounded-lg border border-slate-600 text-slate-300 hover:bg-slate-700">
                        <i class="fas fa-times mr-2"></i> 취소
                    </a>
                </div>
            </form>
        </div>
    </main>
</div>

<!-- 확인 다이얼로그 -->
<div id="confirm-dialog" class="confirm-dialog">
    <div class="confirm-dialog-content">
        <h3 class="text-2xl font-bold text-slate-200 mb-4">
            <i class="fas fa-sitemap mr-2 text-indigo-400"></i>
            계층 구조 최종 확인
        </h3>

        <div class="mb-6">
            <div class="bg-slate-900/50 rounded-lg p-6 border border-slate-700"
                 style="max-height: 50vh; overflow: auto;">
                <div id="confirm-mermaid" class="mermaid" style="min-height: 200px;"></div>
            </div>
            <p class="text-sm text-slate-500 mt-2 text-center">
                <i class="fas fa-info-circle mr-1"></i>
                다이어그램이 크면 스크롤하여 확인하세요
            </p>
        </div>

        <div id="impact-analysis" class="mb-6">
            <!-- 영향 분석 결과가 여기에 표시됩니다 -->
        </div>

        <div class="flex gap-4">
            <button type="button" onclick="submitForm()"
                    class="flex-1 dark-btn-primary">
                <i class="fas fa-check mr-2"></i> 확인 및 저장
            </button>
            <button type="button" onclick="hideConfirmDialog()"
                    class="flex-1 py-3 px-4 rounded-lg border border-slate-600 text-slate-300 hover:bg-slate-700 transition-all">
                <i class="fas fa-times mr-2"></i> 취소
            </button>
        </div>
    </div>
</div>

<div th:insert="~{fragments/footer :: footer}"></div>

<script th:inline="javascript">
    // Thymeleaf에서 전달된 데이터
    const groupsWithRoles = /*[[${groupsWithRoles}]]*/ [];
    const ungroupedRoles = /*[[${ungroupedRoles}]]*/ [];
    let hierarchyPairs = /*[[${hierarchyPairs}]]*/ [];

    // 데이터 정제 - 개행문자 제거
    if (hierarchyPairs && hierarchyPairs.length > 0) {
        hierarchyPairs = hierarchyPairs.map(pair => {
            return {
                parentRole: pair.parentRole ? pair.parentRole.replace(/\\n/g, '').replace(/\n/g, '').trim() : '',
                childRole: pair.childRole ? pair.childRole.replace(/\\n/g, '').replace(/\n/g, '').trim() : ''
            };
        });
    }

    // 디버깅용 로그
    console.log('=== Role Hierarchy Data ===');
    console.log('Groups with roles:', groupsWithRoles);
    console.log('Ungrouped roles:', ungroupedRoles);
    console.log('Existing hierarchy pairs (cleaned):', hierarchyPairs);

    // Mermaid 초기화
    mermaid.initialize({
        startOnLoad: true,
        theme: 'dark',
        themeVariables: {
            primaryColor: '#6366f1',
            primaryTextColor: '#e2e8f0',
            primaryBorderColor: '#4f46e5',
            lineColor: '#60a5fa',
            secondaryColor: '#1e293b',
            tertiaryColor: '#334155',
            background: '#0f172a',
            mainBkg: '#1e293b',
            secondBkg: '#334155',
            tertiaryBkg: '#475569'
        }
    });

    // 전역 변수
    let relationshipGraph = new Map(); // 계층 관계 저장

    // 툴팁 표시
    function showTooltip(event, element) {
        const tooltip = document.getElementById('tooltip');
        const role = element.dataset.role;
        const desc = element.dataset.desc;
        const permissions = element.querySelectorAll('.permission-tag');

        let content = `<strong>${role}</strong><br/>${desc}`;
        if (permissions.length > 0) {
            content += '<br/><br/><strong>권한:</strong><br/>';
            permissions.forEach(p => {
                content += `• ${p.textContent}<br/>`;
            });
        }

        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY + 10 + 'px';
    }

    function hideTooltip() {
        document.getElementById('tooltip').style.display = 'none';
    }

    // 관계 행 추가
    function addRow() {
        console.log('Adding new row...');
        const container = document.getElementById('hierarchy-rows-container');
        if (!container) {
            console.error('Container not found!');
            return;
        }

        const newRow = document.createElement('div');
        newRow.className = 'relation-row';

        let optionsHtml = '';

        // 데이터가 없는 경우 처리
        if (!groupsWithRoles || groupsWithRoles.length === 0) {
            console.warn('No groups with roles data available');
            // 폴백: allRoles 데이터 사용
            const allRolesData = /*[[${allRoles}]]*/ [];
            if (allRolesData && allRolesData.length > 0) {
                optionsHtml = '<optgroup label="모든 역할">';
                allRolesData.forEach(role => {
                    const desc = role.roleDesc || role.roleName;
                    optionsHtml += `<option value="${role.roleName}">${desc} (${role.roleName})</option>`;
                });
                optionsHtml += '</optgroup>';
            }
        } else {
            // 정상적인 경우
            groupsWithRoles.forEach(group => {
                optionsHtml += `<optgroup label="${group.groupName}">`;
                if (group.roles && group.roles.length > 0) {
                    group.roles.forEach(role => {
                        const desc = role.roleDesc || role.roleName;
                        optionsHtml += `<option value="${role.roleName}" data-subtext="${role.roleName}">${desc}</option>`;
                    });
                }
                optionsHtml += '</optgroup>';
            });
        }

        if (ungroupedRoles && ungroupedRoles.length > 0) {
            optionsHtml += '<optgroup label="그룹 미지정">';
            ungroupedRoles.forEach(role => {
                const desc = role.roleDesc || role.roleName;
                optionsHtml += `<option value="${role.roleName}" data-subtext="${role.roleName}">${desc}</option>`;
            });
            optionsHtml += '</optgroup>';
        }

        newRow.innerHTML = `
            <div class="grid grid-cols-12 gap-3 items-center">
                <div class="col-span-5">
                    <div class="modern-select-wrapper">
                        <select class="parent-role modern-select" onchange="validateAndUpdate()">
                            <option value="">상위 역할 선택</option>
                            ${optionsHtml}
                        </select>
                        <div class="select-arrow">
                            <i class="fas fa-chevron-down"></i>
                        </div>
                    </div>
                </div>
                <div class="col-span-2 text-center">
                    <div class="relation-arrow-container">
                        <div class="arrow-line"></div>
                        <i class="fas fa-chevron-right relation-icon"></i>
                    </div>
                </div>
                <div class="col-span-5">
                    <div class="modern-select-wrapper">
                        <select class="child-role modern-select" onchange="validateAndUpdate()">
                            <option value="">하위 역할 선택</option>
                            ${optionsHtml}
                        </select>
                        <div class="select-arrow">
                            <i class="fas fa-chevron-down"></i>
                        </div>
                    </div>
                </div>
            </div>
            <button type="button" onclick="removeRow(this)"
                    class="mt-3 delete-btn">
                <i class="fas fa-trash-alt mr-1"></i> 관계 삭제
            </button>
        `;

        container.appendChild(newRow);
        console.log('New row added');
    }

    // 관계 행 삭제
    function removeRow(button) {
        button.closest('.relation-row').remove();
        validateAndUpdate();
    }

    // 유효성 검증 및 업데이트
    function validateAndUpdate() {
        const rows = document.querySelectorAll('.relation-row');
        const relations = [];
        const graph = new Map();
        let hasError = false;
        let errorMessage = '';
        let warningMessage = '';

        // 관계 수집
        rows.forEach(row => {
            const parent = row.querySelector('.parent-role').value;
            const child = row.querySelector('.child-role').value;

            if (parent && child) {
                if (parent === child) {
                    hasError = true;
                    errorMessage = '상위 역할과 하위 역할이 동일할 수 없습니다.';
                    return;
                }

                relations.push({parent, child});

                if (!graph.has(parent)) {
                    graph.set(parent, new Set());
                }
                graph.get(parent).add(child);
            } else if (parent || child) {
                warningMessage = '상위 역할과 하위 역할을 모두 선택해주세요.';
            }
        });

        // 중복 검사
        const seen = new Set();
        for (const rel of relations) {
            const key = `${rel.parent}>${rel.child}`;
            if (seen.has(key)) {
                hasError = true;
                errorMessage = `중복된 관계가 있습니다: ${key}`;
                break;
            }
            seen.add(key);
        }

        // 역방향 관계 검사
        if (!hasError) {
            for (const rel of relations) {
                const reverseKey = `${rel.child}>${rel.parent}`;
                if (seen.has(reverseKey)) {
                    hasError = true;
                    errorMessage = `역방향 관계가 발견되었습니다: ${rel.parent} ↔ ${rel.child}`;
                    break;
                }
            }
        }

        // 전이적 중복 검사 (A>B, B>C가 있을 때 A>C는 불필요)
        if (!hasError) {
            for (const rel of relations) {
                if (isTransitivelyConnected(graph, rel.parent, rel.child)) {
                    hasError = true;
                    errorMessage = `불필요한 관계입니다: ${rel.parent} > ${rel.child} (이미 다른 경로로 연결되어 있습니다)`;
                    break;
                }
            }
        }

        // 순환 참조 검사
        if (!hasError && graph.size > 0) {
            for (const [node, ] of graph) {
                if (hasCycle(graph, node, new Set(), new Set())) {
                    hasError = true;
                    errorMessage = `순환 참조가 발견되었습니다. ${node}부터 시작하는 경로를 확인하세요.`;
                    break;
                }
            }
        }

        // 에러/경고 표시
        const errorDiv = document.getElementById('validation-error');
        const warningDiv = document.getElementById('validation-warning');

        if (hasError) {
            errorDiv.textContent = errorMessage;
            errorDiv.style.display = 'block';
        } else {
            errorDiv.style.display = 'none';
        }

        if (!hasError && warningMessage) {
            warningDiv.textContent = warningMessage;
            warningDiv.style.display = 'block';
        } else {
            warningDiv.style.display = 'none';
        }

        // 시각화 업데이트
        if (!hasError) {
            if (relations.length > 0) {
                updateVisualization(relations);
                updateResultPreview(relations);
            } else {
                // 관계가 없을 때 초기 상태로 복원
                const container = document.getElementById('mermaid-container');
                container.innerHTML = `<div id="mermaid-diagram" class="mermaid">
                    graph TD
                    A[역할 관계를 설정하면<br/>여기에 시각화됩니다]
                </div>`;
                mermaid.init(undefined, document.getElementById('mermaid-diagram'));

                const preview = document.getElementById('result-preview');
                preview.textContent = '계층 관계를 설정하면 여기에 결과가 표시됩니다.';
            }
        }

        relationshipGraph = graph;
    }

    // 전이적 연결 확인 (A에서 B로 가는 다른 경로가 있는지 확인)
    function isTransitivelyConnected(graph, start, end) {
        // 직접 연결을 임시로 제거하고 다른 경로가 있는지 확인
        const tempGraph = new Map();
        for (const [key, values] of graph) {
            tempGraph.set(key, new Set(values));
        }

        if (tempGraph.has(start)) {
            tempGraph.get(start).delete(end);
        }

        // BFS로 다른 경로 탐색
        const queue = [start];
        const visited = new Set();

        while (queue.length > 0) {
            const current = queue.shift();
            if (visited.has(current)) continue;
            visited.add(current);

            const children = tempGraph.get(current);
            if (children) {
                for (const child of children) {
                    if (child === end) {
                        return true; // 다른 경로로 도달 가능
                    }
                    queue.push(child);
                }
            }
        }

        return false;
    }

    // 순환 참조 검사 (DFS)
    function hasCycle(graph, node, visited, recStack) {
        visited.add(node);
        recStack.add(node);

        const children = graph.get(node);
        if (children) {
            for (const child of children) {
                if (!visited.has(child)) {
                    if (hasCycle(graph, child, visited, recStack)) {
                        return true;
                    }
                } else if (recStack.has(child)) {
                    return true;
                }
            }
        }

        recStack.delete(node);
        return false;
    }

    // 시각화 업데이트
    function updateVisualization(relations) {
        if (relations.length === 0) {
            // 관계가 없을 때 초기 상태로 복원
            showInitialState();
            return;
        }

        // 노드별로 중복 제거를 위한 맵
        const nodeMap = new Map();
        let nodeIndex = 0;

        // Mermaid 코드 생성
        let mermaidCode = 'graph TD\n';

        relations.forEach(rel => {
            // 노드 ID 생성 또는 가져오기
            if (!nodeMap.has(rel.parent)) {
                nodeMap.set(rel.parent, `N${nodeIndex++}`);
            }
            if (!nodeMap.has(rel.child)) {
                nodeMap.set(rel.child, `N${nodeIndex++}`);
            }

            const parentId = nodeMap.get(rel.parent);
            const childId = nodeMap.get(rel.child);

            mermaidCode += `    ${parentId}["${rel.parent}"] --> ${childId}["${rel.child}"]\n`;
        });

        // 스타일 추가
        mermaidCode += '\n    classDef default fill:#1e293b,stroke:#4f46e5,stroke-width:2px,color:#e2e8f0\n';
        mermaidCode += '    classDef highlight fill:#4f46e5,stroke:#6366f1,stroke-width:3px,color:#ffffff\n';

        const container = document.getElementById('mermaid-container');
        const diagramDiv = document.createElement('div');
        diagramDiv.id = 'mermaid-diagram';
        diagramDiv.className = 'mermaid';
        diagramDiv.textContent = mermaidCode;

        container.innerHTML = '';
        container.appendChild(diagramDiv);

        try {
            mermaid.init(undefined, diagramDiv);
        } catch (e) {
            console.error('Mermaid visualization error:', e);
            showInitialState();
        }
    }

    // 결과 미리보기 업데이트
    function updateResultPreview(relations) {
        const preview = document.getElementById('result-preview');
        const hierarchyString = relations.map(rel => `${rel.parent} > ${rel.child}`).join('\n');
        preview.textContent = hierarchyString || '계층 관계를 설정하면 여기에 결과가 표시됩니다.';

        // hidden input 업데이트
        document.getElementById('hierarchyString').value = hierarchyString;
    }

    // 확인 다이얼로그 표시
    function showConfirmDialog() {
        const errorDiv = document.getElementById('validation-error');
        if (errorDiv.style.display === 'block') {
            showToast('유효성 검증 오류를 먼저 해결해주세요.', 'error');
            return;
        }

        const rows = document.querySelectorAll('.relation-row');
        const relations = [];

        rows.forEach(row => {
            const parent = row.querySelector('.parent-role').value;
            const child = row.querySelector('.child-role').value;
            if (parent && child) {
                relations.push({parent, child});
            }
        });

        if (relations.length === 0) {
            showToast('최소 하나 이상의 관계를 설정해주세요.', 'warning');
            return;
        }

        // 노드별로 중복 제거를 위한 맵
        const nodeMap = new Map();
        const nodeStyles = new Map();
        let nodeIndex = 0;

        // 계층 레벨 계산을 위한 구조
        const levels = new Map();
        const graph = new Map();

        // 그래프 구성
        relations.forEach(rel => {
            if (!graph.has(rel.parent)) {
                graph.set(rel.parent, new Set());
            }
            graph.get(rel.parent).add(rel.child);
        });

        // 루트 노드 찾기 (부모가 없는 노드)
        const allChildren = new Set();
        relations.forEach(rel => allChildren.add(rel.child));
        const roots = Array.from(new Set(relations.map(r => r.parent)))
            .filter(node => !allChildren.has(node));

        // BFS로 레벨 할당
        const queue = roots.map(root => ({node: root, level: 0}));
        const visited = new Set();

        while (queue.length > 0) {
            const {node, level} = queue.shift();
            if (visited.has(node)) continue;

            visited.add(node);
            levels.set(node, level);

            const children = graph.get(node);
            if (children) {
                children.forEach(child => {
                    queue.push({node: child, level: level + 1});
                });
            }
        }

        // Mermaid 코드 생성 (큰 그래프를 위한 최적화)
        let mermaidCode = 'graph TB\n'; // TB (Top to Bottom)으로 변경

        // 노드 정의
        relations.forEach(rel => {
            if (!nodeMap.has(rel.parent)) {
                const id = `N${nodeIndex++}`;
                nodeMap.set(rel.parent, id);
                const level = levels.get(rel.parent) || 0;
                nodeStyles.set(rel.parent, level);
            }
            if (!nodeMap.has(rel.child)) {
                const id = `N${nodeIndex++}`;
                nodeMap.set(rel.child, id);
                const level = levels.get(rel.child) || 1;
                nodeStyles.set(rel.child, level);
            }
        });

        // 관계 정의
        relations.forEach(rel => {
            const parentId = nodeMap.get(rel.parent);
            const childId = nodeMap.get(rel.child);
            const parentLevel = nodeStyles.get(rel.parent);
            const childLevel = nodeStyles.get(rel.child);

            // 역할 설명 찾기
            let parentDesc = rel.parent;
            let childDesc = rel.child;

            groupsWithRoles.forEach(group => {
                group.roles.forEach(role => {
                    if (role.roleName === rel.parent) {
                        parentDesc = role.roleDesc || rel.parent;
                    }
                    if (role.roleName === rel.child) {
                        childDesc = role.roleDesc || rel.child;
                    }
                });
            });

            // Mermaid에서는 \n으로 개행 처리
            mermaidCode += `    ${parentId}["${parentDesc}\\n${rel.parent}"] --> ${childId}["${childDesc}\\n${rel.child}"]\n`;
        });

        // 레벨별 스타일 적용
        const levelColors = ['#4f46e5', '#7c3aed', '#2563eb', '#0891b2', '#059669'];
        for (let i = 0; i < 5; i++) {
            const nodesAtLevel = Array.from(nodeStyles.entries())
                .filter(([node, level]) => level === i)
                .map(([node, level]) => nodeMap.get(node));

            if (nodesAtLevel.length > 0) {
                mermaidCode += `    classDef level${i} fill:${levelColors[i % levelColors.length]},stroke:#fff,stroke-width:2px,color:#fff\n`;
                mermaidCode += `    class ${nodesAtLevel.join(',')} level${i}\n`;
            }
        }

        // 다이어그램 크기 및 스크롤 처리를 위한 설정
        const confirmMermaid = document.getElementById('confirm-mermaid');

        // 다이어그램을 div에 텍스트로 설정
        confirmMermaid.textContent = mermaidCode;
        confirmMermaid.removeAttribute('data-processed'); // 재처리를 위해 속성 제거

        // Mermaid 설정 (큰 다이어그램 최적화)
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            flowchart: {
                nodeSpacing: 50,
                rankSpacing: 80,
                curve: 'basis',
                useMaxWidth: false // 자동 크기 조정 비활성화
            },
            themeVariables: {
                primaryColor: '#6366f1',
                primaryTextColor: '#ffffff',
                primaryBorderColor: '#4f46e5',
                lineColor: '#60a5fa',
                background: '#1e293b',
                mainBkg: '#1e293b',
                fontFamily: 'Inter, sans-serif',
                fontSize: '14px'
            }
        });

        try {
            mermaid.init(undefined, confirmMermaid);
        } catch (e) {
            console.error('Mermaid init error:', e);
            // 오류 발생 시 단순한 다이어그램으로 대체
            let simpleMermaidCode = 'graph TB\n';
            relations.forEach((rel, idx) => {
                const parentId = `P${idx}`;
                const childId = `C${idx}`;
                simpleMermaidCode += `    ${parentId}[${rel.parent}] --> ${childId}[${rel.child}]\n`;
            });
            confirmMermaid.textContent = simpleMermaidCode;
            mermaid.init(undefined, confirmMermaid);
        }

        // 영향 분석
        const impactDiv = document.getElementById('impact-analysis');
        const allRoles = new Set();
        relations.forEach(rel => {
            allRoles.add(rel.parent);
            allRoles.add(rel.child);
        });

        // 계층 깊이 계산
        const maxDepth = Math.max(...Array.from(levels.values())) + 1;

        impactDiv.innerHTML = `
            <div class="grid grid-cols-3 gap-4">
                <div class="bg-slate-800 p-4 rounded-lg text-center">
                    <div class="text-3xl font-bold text-indigo-400">${relations.length}</div>
                    <div class="text-sm text-slate-400 mt-1">관계 설정</div>
                </div>
                <div class="bg-slate-800 p-4 rounded-lg text-center">
                    <div class="text-3xl font-bold text-purple-400">${allRoles.size}</div>
                    <div class="text-sm text-slate-400 mt-1">포함된 역할</div>
                </div>
                <div class="bg-slate-800 p-4 rounded-lg text-center">
                    <div class="text-3xl font-bold text-cyan-400">${maxDepth}</div>
                    <div class="text-sm text-slate-400 mt-1">계층 깊이</div>
                </div>
            </div>
            ${document.getElementById('isActive').checked ?
            '<div class="mt-4 bg-yellow-900/30 border border-yellow-600/50 rounded-lg p-4"><p class="text-yellow-400"><i class="fas fa-exclamation-triangle mr-2"></i>이 계층이 활성화되면 기존 활성 계층은 비활성화됩니다.</p></div>' : ''}
            ${relations.length > 20 ?
            '<div class="mt-4 bg-blue-900/30 border border-blue-600/50 rounded-lg p-4"><p class="text-blue-400"><i class="fas fa-info-circle mr-2"></i>대규모 계층 구조입니다. 다이어그램을 스크롤하여 전체를 확인하세요.</p></div>' : ''}
        `;

        document.getElementById('confirm-dialog').style.display = 'flex';
    }

    function hideConfirmDialog() {
        document.getElementById('confirm-dialog').style.display = 'none';
    }

    function submitForm() {
        document.getElementById('hierarchyForm').submit();
    }

    // 초기 상태 표시
    function showInitialState() {
        const container = document.getElementById('mermaid-container');
        if (container) {
            const diagramDiv = document.createElement('div');
            diagramDiv.id = 'mermaid-diagram';
            diagramDiv.className = 'mermaid';
            diagramDiv.textContent = 'graph TD\n    A[역할 관계를 설정하면 여기에 시각화됩니다]';

            container.innerHTML = '';
            container.appendChild(diagramDiv);

            if (typeof mermaid !== 'undefined') {
                try {
                    mermaid.init(undefined, diagramDiv);
                } catch (e) {
                    console.error('Mermaid init error:', e);
                }
            }
        }

        const preview = document.getElementById('result-preview');
        if (preview) {
            preview.textContent = '계층 관계를 설정하면 여기에 결과가 표시됩니다.';
        }
    }

    // showToast 함수
    function showToast(message, type) {
        const toastContainer = document.getElementById('toast-container');
        if (!toastContainer) return;

        const toast = document.createElement('div');
        toast.className = `toast-message toast-${type} fade-in`;
        toast.textContent = message;

        toastContainer.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('fade-out');
            setTimeout(() => toast.remove(), 500);
        }, 3000);
    }

    // 페이지 로드 시 초기화
    document.addEventListener('DOMContentLoaded', function() {
        console.log('=== DOMContentLoaded - Role Hierarchy Editor ===');
        console.log('Groups with roles:', groupsWithRoles);
        console.log('Ungrouped roles:', ungroupedRoles);
        console.log('Existing pairs:', hierarchyPairs);

        // Mermaid 재초기화 (이미 초기화되어 있을 수 있으므로)
        if (typeof mermaid !== 'undefined') {
            mermaid.init();
        }

        // 이벤트 리스너 추가
        const addBtn = document.getElementById('add-row-btn');
        if (addBtn) {
            addBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Add button clicked');
                addRow();
            });
        } else {
            console.error('Add button not found!');
        }

        // 폼 제출 이벤트 리스너 추가
        const form = document.getElementById('hierarchyForm');
        if (form) {
            form.addEventListener('submit', function(e) {
                // 폼 제출 전, UI의 모든 관계를 읽어 hidden input에 문자열로 변환하여 저장
                const rows = document.querySelectorAll('.relation-row');
                const hierarchyPairs = [];
                let isValid = true;

                rows.forEach(row => {
                    const parentRole = row.querySelector('.parent-role').value;
                    const childRole = row.querySelector('.child-role').value;
                    if (parentRole && childRole) {
                        hierarchyPairs.push(`${parentRole} > ${childRole}`);
                    } else if (parentRole || childRole) {
                        // 둘 중 하나만 선택된 경우 경고
                        isValid = false;
                    }
                });

                if (!isValid) {
                    e.preventDefault(); // 폼 제출 중단
                    showToast('상위 역할과 하위 역할을 모두 선택해야 합니다.', 'error');
                    return;
                }

                if (hierarchyPairs.length === 0) {
                    e.preventDefault();
                    showToast('최소 하나 이상의 관계를 설정해야 합니다.', 'error');
                    return;
                }

                // 개행문자로 구분된 문자열 생성
                const hierarchyString = hierarchyPairs.join('\n');
                document.getElementById('hierarchyString').value = hierarchyString;

                console.log('Submitting hierarchy string:', hierarchyString);
                console.log('Number of relations:', hierarchyPairs.length);
            });
        }

        // 기존 데이터 확인 및 시각화
        const existingRows = document.querySelectorAll('.relation-row');
        console.log('Found existing rows:', existingRows.length);

        if (existingRows.length > 0) {
            // 각 행의 값 확인
            existingRows.forEach((row, index) => {
                const parentSelect = row.querySelector('.parent-role');
                const childSelect = row.querySelector('.child-role');
                if (parentSelect && childSelect) {
                    console.log(`Row ${index}: parent=${parentSelect.value}, child=${childSelect.value}`);
                }
            });

            // 약간의 지연 후 검증 실행
            setTimeout(() => {
                console.log('Running initial validation...');
                validateAndUpdate();
            }, 200);
        } else {
            // 초기 상태 표시
            console.log('No existing relations, showing initial state');
            showInitialState();
        }
    });
</script>
</body>
</html>