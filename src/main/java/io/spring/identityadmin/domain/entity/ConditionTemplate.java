package io.spring.identityadmin.domain.entity;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Objects;

/**
 * ì¼ë°˜ ì‚¬ìš©ìê°€ ì¸ê°€ ì •ì±…ì„ ì„¤ì •í•  ë•Œ ì„ íƒí•  ìˆ˜ ìˆëŠ”, ë¯¸ë¦¬ ì •ì˜ëœ ì¡°ê±´ í…œí”Œë¦¿ì„ ì •ì˜í•˜ëŠ” ì—”í‹°í‹°.
 * (ì˜ˆ: 'ì—…ë¬´ ì‹œê°„ì—ë§Œ í—ˆìš©', 'ì‚¬ë‚´ IPì—ì„œë§Œ í—ˆìš©' ë“±)
 */
@Entity
@Table(name = "CONDITION_TEMPLATE")
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ConditionTemplate implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name; // ì‚¬ìš©ìì—ê²Œ í‘œì‹œë  ì¡°ê±´ ì´ë¦„ (ì˜ˆ: ì—…ë¬´ ì‹œê°„ ì œì•½)

    @Column(nullable = false, length = 2048)
    private String spelTemplate; // ì´ ì¡°ê±´ì´ ì„ íƒë˜ì—ˆì„ ë•Œ ì‹¤ì œë¡œ ìƒì„±ë  SpEL í‘œí˜„ì‹ (ì˜ˆ: #isBusinessHours())

    @Column
    private String category; // UIì—ì„œ ì¡°ê±´ì„ ê·¸ë£¹í•‘í•˜ê¸° ìœ„í•œ ì¹´í…Œê³ ë¦¬ (ì˜ˆ: ì‹œê°„ ê¸°ë°˜, ìœ„ì¹˜ ê¸°ë°˜)

    @Column
    private int parameterCount; // ì´ ì¡°ê±´ì„ ì‚¬ìš©í•˜ëŠ” ë° í•„ìš”í•œ íŒŒë¼ë¯¸í„° ìˆ˜ (ì˜ˆ: 'ê¸ˆì•¡ ë¹„êµ' ì¡°ê±´ì€ 1ê°œì˜ íŒŒë¼ë¯¸í„° í•„ìš”)

    @Column(length = 1024)
    private String description; // ì¡°ê±´ì— ëŒ€í•œ ì„¤ëª…

    @Column(length = 1024)
    private String requiredTargetType;

    // ìë™ ìƒì„± ê´€ë ¨ í•„ë“œë“¤
    @Column(name = "is_auto_generated")
    private Boolean isAutoGenerated = false; // ìë™ ìƒì„±ëœ í…œí”Œë¦¿ì¸ì§€ ì—¬ë¶€
    
    @Column(name = "template_type")
    private String templateType; // í…œí”Œë¦¿ íƒ€ì… (universal, object_return, id_parameter ë“±)
    
    @Column(name = "source_method")
    private String sourceMethod; // ì´ í…œí”Œë¦¿ì´ ìƒì„±ëœ ì†ŒìŠ¤ ë©”ì„œë“œ
    
    @Column(name = "is_universal")
    private Boolean isUniversal = false; // ë²”ìš© ì¡°ê±´ì¸ì§€ ì—¬ë¶€
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // ğŸ”„ 2ë‹¨ê³„: ì¡°ê±´ ë¶„ë¥˜ ì‹œìŠ¤í…œ í•„ë“œë“¤
    @Column(name = "complexity_score")
    private Integer complexityScore = 1; // 1-10 ë³µì¡ë„ ì ìˆ˜
    
    @Column(name = "risk_level")
    @Enumerated(EnumType.STRING)
    private RiskLevel riskLevel = RiskLevel.LOW; // ìœ„í—˜ë„
    
    @Column(name = "approval_required")
    private Boolean approvalRequired = false; // ìŠ¹ì¸ í•„ìš” ì—¬ë¶€
    
    @Column(name = "context_dependent")
    private Boolean contextDependent = false; // ì»¨í…ìŠ¤íŠ¸ ì˜ì¡´ì„±
    
    @Column(name = "classification")
    @Enumerated(EnumType.STRING)
    private ConditionClassification classification = ConditionClassification.UNIVERSAL; // ì¡°ê±´ ë¶„ë¥˜

    /**
     * ì¡°ê±´ ìœ„í—˜ë„ ì—´ê±°í˜•
     */
    public enum RiskLevel {
        LOW,    // ë‚®ìŒ - ë²”ìš© ì¡°ê±´
        MEDIUM, // ì¤‘ê°„ - ì»¨í…ìŠ¤íŠ¸ ì˜ì¡´
        HIGH    // ë†’ìŒ - ì»¤ìŠ¤í…€/ë³µì¡í•œ ì¡°ê±´
    }
    
    /**
     * ì¡°ê±´ ë¶„ë¥˜ ì—´ê±°í˜•
     */
    public enum ConditionClassification {
        UNIVERSAL,          // ğŸŸ¢ ë²”ìš© ì¡°ê±´ (ì¦‰ì‹œ ì‚¬ìš©)
        CONTEXT_DEPENDENT,  // ğŸŸ¡ ì»¨í…ìŠ¤íŠ¸ ì˜ì¡´ ì¡°ê±´ (AI ê²€ì¦)
        CUSTOM_COMPLEX      // ğŸ”´ ì»¤ìŠ¤í…€ ë³µì¡ ì¡°ê±´ (ì „ë¬¸ê°€ ê²€í† )
    }

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
        
        // ê¸°ë³¸ ë¶„ë¥˜ ë¡œì§
        if (classification == null) {
            autoClassifyCondition();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    /**
     * ì¡°ê±´ì˜ íŠ¹ì„±ì„ ë¶„ì„í•˜ì—¬ ìë™ìœ¼ë¡œ ë¶„ë¥˜í•©ë‹ˆë‹¤.
     */
    private void autoClassifyCondition() {
        if (spelTemplate == null) {
            return;
        }
        
        // SpEL í…œí”Œë¦¿ ë¶„ì„ì„ í†µí•œ ìë™ ë¶„ë¥˜
        int score = calculateComplexityScore();
        this.complexityScore = score;
        
        // ë³µì¡ë„ì— ë”°ë¥¸ ë¶„ë¥˜
        if (score <= 3) {
            this.classification = ConditionClassification.UNIVERSAL;
            this.riskLevel = RiskLevel.LOW;
            this.contextDependent = false;
            this.approvalRequired = false;
        } else if (score <= 6) {
            this.classification = ConditionClassification.CONTEXT_DEPENDENT;
            this.riskLevel = RiskLevel.MEDIUM;
            this.contextDependent = true;
            this.approvalRequired = false; // AI ê²€ì¦ë§Œ í•„ìš”
        } else {
            this.classification = ConditionClassification.CUSTOM_COMPLEX;
            this.riskLevel = RiskLevel.HIGH;
            this.contextDependent = true;
            this.approvalRequired = true; // ì „ë¬¸ê°€ ê²€í†  í•„ìš”
        }
    }
    
    /**
     * SpEL í…œí”Œë¦¿ì˜ ë³µì¡ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
     */
    private int calculateComplexityScore() {
        if (spelTemplate == null || spelTemplate.trim().isEmpty()) {
            return 1;
        }
        
        int score = 1; // ê¸°ë³¸ ì ìˆ˜
        String spel = spelTemplate.toLowerCase();
        
        // ë³€ìˆ˜ ì‚¬ìš© ê°œìˆ˜ (+1ì ì”©)
        score += countOccurrences(spel, "#");
        
        // ë©”ì„œë“œ í˜¸ì¶œ ê°œìˆ˜ (+1ì ì”©)
        score += countOccurrences(spel, "(");
        
        // ë…¼ë¦¬ ì—°ì‚°ì (+1ì ì”©)
        score += countOccurrences(spel, "&&");
        score += countOccurrences(spel, "||");
        score += countOccurrences(spel, "and");
        score += countOccurrences(spel, "or");
        
        // ë¹„êµ ì—°ì‚°ì (+0.5ì ì”©)
        score += (countOccurrences(spel, "==") + countOccurrences(spel, "!=") + 
                 countOccurrences(spel, ">=") + countOccurrences(spel, "<=")) / 2;
        
        // íŠ¹ë³„í•œ í•¨ìˆ˜ë“¤ (ë†’ì€ ë³µì¡ë„)
        if (spel.contains("haspermission")) score += 2;
        if (spel.contains("hasrole") || spel.contains("hasauthority")) score += 1;
        if (spel.contains("returnobject")) score += 2;
        if (spel.contains("authentication")) score += 1;
        
        return Math.min(score, 10); // ìµœëŒ€ 10ì 
    }
    
    /**
     * ë¬¸ìì—´ì—ì„œ íŠ¹ì • íŒ¨í„´ì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” í—¬í¼ ë©”ì„œë“œ
     */
    private int countOccurrences(String text, String pattern) {
        int count = 0;
        int index = 0;
        while ((index = text.indexOf(pattern, index)) != -1) {
            count++;
            index += pattern.length();
        }
        return count;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ConditionTemplate that)) return false;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
