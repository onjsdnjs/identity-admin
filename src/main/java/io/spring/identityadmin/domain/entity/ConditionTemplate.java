package io.spring.identityadmin.domain.entity;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Objects;

/**
 * 일반 사용자가 인가 정책을 설정할 때 선택할 수 있는, 미리 정의된 조건 템플릿을 정의하는 엔티티.
 * (예: '업무 시간에만 허용', '사내 IP에서만 허용' 등)
 */
@Entity
@Table(name = "CONDITION_TEMPLATE")
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ConditionTemplate implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name; // 사용자에게 표시될 조건 이름 (예: 업무 시간 제약)

    @Column(nullable = false, length = 2048)
    private String spelTemplate; // 이 조건이 선택되었을 때 실제로 생성될 SpEL 표현식 (예: #isBusinessHours())

    @Column
    private String category; // UI에서 조건을 그룹핑하기 위한 카테고리 (예: 시간 기반, 위치 기반)

    @Column
    private int parameterCount; // 이 조건을 사용하는 데 필요한 파라미터 수 (예: '금액 비교' 조건은 1개의 파라미터 필요)

    @Column(length = 1024)
    private String description; // 조건에 대한 설명

    @Column(length = 1024)
    private String requiredTargetType;

    // 자동 생성 관련 필드들
    @Column(name = "is_auto_generated")
    private Boolean isAutoGenerated = false; // 자동 생성된 템플릿인지 여부
    
    @Column(name = "template_type")
    private String templateType; // 템플릿 타입 (universal, object_return, id_parameter 등)
    
    @Column(name = "source_method")
    private String sourceMethod; // 이 템플릿이 생성된 소스 메서드
    
    @Column(name = "is_universal")
    private Boolean isUniversal = false; // 범용 조건인지 여부
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // 🔄 2단계: 조건 분류 시스템 필드들
    @Column(name = "complexity_score")
    private Integer complexityScore = 1; // 1-10 복잡도 점수
    
    @Column(name = "risk_level")
    @Enumerated(EnumType.STRING)
    private RiskLevel riskLevel = RiskLevel.LOW; // 위험도
    
    @Column(name = "approval_required")
    private Boolean approvalRequired = false; // 승인 필요 여부
    
    @Column(name = "context_dependent")
    private Boolean contextDependent = false; // 컨텍스트 의존성
    
    @Column(name = "classification")
    @Enumerated(EnumType.STRING)
    private ConditionClassification classification = ConditionClassification.UNIVERSAL; // 조건 분류

    /**
     * 조건 위험도 열거형
     */
    public enum RiskLevel {
        LOW,    // 낮음 - 범용 조건
        MEDIUM, // 중간 - 컨텍스트 의존
        HIGH    // 높음 - 커스텀/복잡한 조건
    }
    
    /**
     * 조건 분류 열거형
     */
    public enum ConditionClassification {
        UNIVERSAL,          // 🟢 범용 조건 (즉시 사용)
        CONTEXT_DEPENDENT,  // 🟡 컨텍스트 의존 조건 (AI 검증)
        CUSTOM_COMPLEX      // 🔴 커스텀 복잡 조건 (전문가 검토)
    }

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
        
        // 기본 분류 로직
        if (classification == null) {
            autoClassifyCondition();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    /**
     * 조건의 특성을 분석하여 자동으로 분류합니다.
     */
    private void autoClassifyCondition() {
        if (spelTemplate == null) {
            return;
        }
        
        // SpEL 템플릿 분석을 통한 자동 분류
        int score = calculateComplexityScore();
        this.complexityScore = score;
        
        // 복잡도에 따른 분류
        if (score <= 3) {
            this.classification = ConditionClassification.UNIVERSAL;
            this.riskLevel = RiskLevel.LOW;
            this.contextDependent = false;
            this.approvalRequired = false;
        } else if (score <= 6) {
            this.classification = ConditionClassification.CONTEXT_DEPENDENT;
            this.riskLevel = RiskLevel.MEDIUM;
            this.contextDependent = true;
            this.approvalRequired = false; // AI 검증만 필요
        } else {
            this.classification = ConditionClassification.CUSTOM_COMPLEX;
            this.riskLevel = RiskLevel.HIGH;
            this.contextDependent = true;
            this.approvalRequired = true; // 전문가 검토 필요
        }
    }
    
    /**
     * SpEL 템플릿의 복잡도를 계산합니다.
     */
    private int calculateComplexityScore() {
        if (spelTemplate == null || spelTemplate.trim().isEmpty()) {
            return 1;
        }
        
        int score = 1; // 기본 점수
        String spel = spelTemplate.toLowerCase();
        
        // 변수 사용 개수 (+1점씩)
        score += countOccurrences(spel, "#");
        
        // 메서드 호출 개수 (+1점씩)
        score += countOccurrences(spel, "(");
        
        // 논리 연산자 (+1점씩)
        score += countOccurrences(spel, "&&");
        score += countOccurrences(spel, "||");
        score += countOccurrences(spel, "and");
        score += countOccurrences(spel, "or");
        
        // 비교 연산자 (+0.5점씩)
        score += (countOccurrences(spel, "==") + countOccurrences(spel, "!=") + 
                 countOccurrences(spel, ">=") + countOccurrences(spel, "<=")) / 2;
        
        // 특별한 함수들 (높은 복잡도)
        if (spel.contains("haspermission")) score += 2;
        if (spel.contains("hasrole") || spel.contains("hasauthority")) score += 1;
        if (spel.contains("returnobject")) score += 2;
        if (spel.contains("authentication")) score += 1;
        
        return Math.min(score, 10); // 최대 10점
    }
    
    /**
     * 문자열에서 특정 패턴의 개수를 세는 헬퍼 메서드
     */
    private int countOccurrences(String text, String pattern) {
        int count = 0;
        int index = 0;
        while ((index = text.indexOf(pattern, index)) != -1) {
            count++;
            index += pattern.length();
        }
        return count;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ConditionTemplate that)) return false;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
