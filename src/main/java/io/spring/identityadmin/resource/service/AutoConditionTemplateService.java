package io.spring.identityadmin.resource.service;

import io.spring.identityadmin.ai.AINativeIAMAdvisor;
import io.spring.identityadmin.domain.entity.ConditionTemplate;
import io.spring.identityadmin.domain.entity.ManagedResource;
import io.spring.identityadmin.domain.entity.Permission;
import io.spring.identityadmin.repository.ConditionTemplateRepository;
import io.spring.identityadmin.repository.ManagedResourceRepository;
import io.spring.identityadmin.repository.PermissionRepository;
import io.spring.identityadmin.resource.MethodPatternAnalyzer;
import io.spring.identityadmin.resource.MethodPatternAnalyzer.MethodAnalysisResult;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AutoConditionTemplateService {

    private final ConditionTemplateRepository conditionTemplateRepository;
    private final MethodPatternAnalyzer methodPatternAnalyzer;
    private final PermissionRepository permissionRepository;
    private final ManagedResourceRepository managedResourceRepository;
    private final AINativeIAMAdvisor aiAdvisor;
    private final ObjectMapper objectMapper;

    /**
     * 자동 생성된 조건 템플릿 정보를 담는 DTO
     */
    public static class AutoGeneratedTemplate {
        private String name;
        private String description;
        private String spelTemplate;
        private String templateType;
        private String sourceMethod;
        private boolean isUniversal;
        private Map<String, Object> metadata;

        // 생성자, getter, setter
        public AutoGeneratedTemplate(String name, String description, String spelTemplate, 
                                   String templateType, String sourceMethod, boolean isUniversal) {
            this.name = name;
            this.description = description;
            this.spelTemplate = spelTemplate;
            this.templateType = templateType;
            this.sourceMethod = sourceMethod;
            this.isUniversal = isUniversal;
            this.metadata = new HashMap<>();
        }

        // Getters and Setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        public String getSpelTemplate() { return spelTemplate; }
        public void setSpelTemplate(String spelTemplate) { this.spelTemplate = spelTemplate; }
        public String getTemplateType() { return templateType; }
        public void setTemplateType(String templateType) { this.templateType = templateType; }
        public String getSourceMethod() { return sourceMethod; }
        public void setSourceMethod(String sourceMethod) { this.sourceMethod = sourceMethod; }
        public boolean isUniversal() { return isUniversal; }
        public void setUniversal(boolean universal) { isUniversal = universal; }
        public Map<String, Object> getMetadata() { return metadata; }
        public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    }

    /**
     * 메서드 분석 결과를 바탕으로 조건 템플릿을 자동 생성합니다.
     */
    @Transactional
    public List<ConditionTemplate> generateTemplatesFromAnalysis(List<MethodAnalysisResult> analysisResults) {
        log.info("🔄 자동 조건 템플릿 생성 시작: {} 개 분석 결과", analysisResults.size());

        List<ConditionTemplate> generatedTemplates = new ArrayList<>();

        // 1. 범용 조건 템플릿 생성 (한 번만)
        List<ConditionTemplate> universalTemplates = generateUniversalTemplates();
        generatedTemplates.addAll(universalTemplates);

        // 2. 메서드별 특화 템플릿 생성
        for (MethodAnalysisResult analysis : analysisResults) {
            List<ConditionTemplate> methodTemplates = generateMethodSpecificTemplates(analysis);
            generatedTemplates.addAll(methodTemplates);
        }

        // 3. 중복 제거 및 DB 저장
        List<ConditionTemplate> savedTemplates = saveDedupedTemplates(generatedTemplates);

        log.info("✅ 자동 조건 템플릿 생성 완료: {} 개 템플릿 저장", savedTemplates.size());
        return savedTemplates;
    }

    /**
     * 범용 조건 템플릿들을 생성합니다. (hasPermission 방식)
     */
    private List<ConditionTemplate> generateUniversalTemplates() {
        List<AutoGeneratedTemplate> universalTemplates = Arrays.asList(
            // 시간 기반 조건들
            new AutoGeneratedTemplate(
                "업무시간 접근",
                "평일 오전 9시부터 오후 6시까지만 접근 허용",
                "T(java.time.LocalTime).now().hour >= 9 and T(java.time.LocalTime).now().hour <= 18",
                "universal", "system_generated", true),
            
            new AutoGeneratedTemplate(
                "평일 접근",
                "월요일부터 금요일까지만 접근 허용",
                "T(java.time.LocalDate).now().dayOfWeek.value <= 5",
                "universal", "system_generated", true),

            // IP 기반 조건들
            new AutoGeneratedTemplate(
                "내부망 접근",
                "192.168.x.x 대역에서만 접근 허용",
                "#request.remoteAddr matches '^192\\\\.168\\\\..*'",
                "universal", "system_generated", true),

            new AutoGeneratedTemplate(
                "사내망 접근",
                "10.x.x.x 대역에서만 접근 허용",
                "#request.remoteAddr matches '^10\\\\..*'",
                "universal", "system_generated", true),

            // 인증된 사용자 기반 조건들
            new AutoGeneratedTemplate(
                "인증된 사용자",
                "로그인한 사용자만 접근 허용",
                "isAuthenticated()",
                "universal", "system_generated", true),

            new AutoGeneratedTemplate(
                "완전 인증된 사용자",
                "완전히 인증된 사용자만 접근 허용 (Remember-me 제외)",
                "isFullyAuthenticated()",
                "universal", "system_generated", true)
        );

        return universalTemplates.stream()
            .map(this::convertToConditionTemplate)
            .collect(Collectors.toList());
    }

    /**
     * 특정 메서드에 대한 조건 템플릿들을 생성합니다.
     */
    private List<ConditionTemplate> generateMethodSpecificTemplates(MethodAnalysisResult analysis) {
        List<AutoGeneratedTemplate> templates = new ArrayList<>();

        switch (analysis.getDetectedPattern()) {
            case OBJECT_RETURN_PATTERN:
                templates.addAll(generateObjectReturnTemplates(analysis));
                break;
            case ID_PARAMETER_PATTERN:
                templates.addAll(generateIdParameterTemplates(analysis));
                break;
            case UNIVERSAL_PATTERN:
                // 범용 패턴은 이미 처리됨
                break;
            default:
                log.debug("지원하지 않는 패턴으로 템플릿 생성 스킵: {}", analysis.getDetectedPattern());
        }

        return templates.stream()
            .map(this::convertToConditionTemplate)
            .collect(Collectors.toList());
    }

    /**
     * 객체 반환 패턴 템플릿 생성 (hasPermission 방식)
     */
    private List<AutoGeneratedTemplate> generateObjectReturnTemplates(MethodAnalysisResult analysis) {
        String entityType = (String) analysis.getMetadata().get("entityType");
        String methodId = analysis.getMethodIdentifier();

        // 🔄 개선: 한국어 친화적인 조건명 생성
        String koreanEntityName = getKoreanEntityName(entityType);
        String methodName = extractMethodName(methodId);

        return Arrays.asList(
            new AutoGeneratedTemplate(
                String.format("특정 %s 읽기 권한", koreanEntityName),
                String.format("조회된 특정 %s 객체에 대한 개별 읽기 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "hasPermission(#returnObject, 'READ')",
                "object_return", methodId, false),

            new AutoGeneratedTemplate(
                String.format("특정 %s 수정 권한", koreanEntityName),
                String.format("조회된 특정 %s 객체에 대한 개별 수정 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "hasPermission(#returnObject, 'UPDATE')",
                "object_return", methodId, false),

            new AutoGeneratedTemplate(
                String.format("특정 %s 삭제 권한", koreanEntityName),
                String.format("조회된 특정 %s 객체에 대한 개별 삭제 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "hasPermission(#returnObject, 'DELETE')",
                "object_return", methodId, false)
        );
    }

    /**
     * ID 파라미터 패턴 템플릿 생성 (hasPermission 방식)
     */
    private List<AutoGeneratedTemplate> generateIdParameterTemplates(MethodAnalysisResult analysis) {
        String entityType = (String) analysis.getMetadata().get("entityType");
        String idParamName = (String) analysis.getMetadata().get("idParameterName");
        String methodId = analysis.getMethodIdentifier();

        // 🔄 개선: 한국어 친화적인 조건명 생성
        String koreanEntityName = getKoreanEntityName(entityType);
        String actionName = extractActionFromMethod(methodId);

        return Arrays.asList(
            new AutoGeneratedTemplate(
                String.format("개별 %s %s 권한", koreanEntityName, actionName),
                String.format("특정 ID의 %s 객체에 대한 개별 %s 권한을 확인합니다", koreanEntityName, actionName),
                String.format("hasPermission(#%s, '%s', 'UPDATE')", idParamName, entityType.toUpperCase()),
                "id_parameter", methodId, false),

            new AutoGeneratedTemplate(
                String.format("개별 %s 삭제 권한", koreanEntityName),
                String.format("특정 ID의 %s 객체에 대한 개별 삭제 권한을 확인합니다", koreanEntityName),
                String.format("hasPermission(#%s, '%s', 'DELETE')", idParamName, entityType.toUpperCase()),
                "id_parameter", methodId, false)
        );
    }

    /**
     * 🔄 개선: 엔티티 타입을 한국어로 변환
     */
    private String getKoreanEntityName(String entityType) {
        if (entityType == null) return "리소스";
        
        Map<String, String> entityNames = Map.of(
            "User", "사용자",
            "Document", "문서", 
            "Group", "그룹",
            "Role", "역할",
            "Permission", "권한",
            "Policy", "정책",
            "Resource", "리소스",
            "File", "파일",
            "Project", "프로젝트",
            "Organization", "조직"
        );
        
        return entityNames.getOrDefault(entityType, entityType.toLowerCase());
    }

    /**
     * 🔄 개선: 메서드명에서 액션 타입 추출
     */
    private String extractActionFromMethod(String methodName) {
        if (methodName == null) return "처리";
        
        String lowerMethod = methodName.toLowerCase();
        
        if (lowerMethod.contains("update") || lowerMethod.contains("modify") || lowerMethod.contains("edit")) {
            return "수정";
        } else if (lowerMethod.contains("delete") || lowerMethod.contains("remove")) {
            return "삭제";
        } else if (lowerMethod.contains("create") || lowerMethod.contains("add") || lowerMethod.contains("insert")) {
            return "생성";
        } else if (lowerMethod.contains("read") || lowerMethod.contains("get") || lowerMethod.contains("find") || lowerMethod.contains("view")) {
            return "조회";
        } else if (lowerMethod.contains("approve")) {
            return "승인";
        } else if (lowerMethod.contains("reject")) {
            return "거부";
        } else if (lowerMethod.contains("assign")) {
            return "할당";
        } else if (lowerMethod.contains("revoke")) {
            return "취소";
        }
        
        return "처리";
    }

    /**
     * 🔄 개선: 메서드 ID에서 메서드명만 추출
     */
    private String extractMethodName(String methodId) {
        if (methodId == null) return "unknown";
        
        String[] parts = methodId.split("\\.");
        return parts.length > 0 ? parts[parts.length - 1] : methodId;
    }
    
    /**
     * 메서드 ID에서 고유한 접미사를 생성합니다.
     */
    private String generateMethodSuffix(String methodId) {
        // 메서드 ID에서 클래스명과 메서드명을 추출하여 짧은 접미사 생성
        if (methodId == null) return "AUTO";
        
        String[] parts = methodId.split("\\.");
        if (parts.length >= 2) {
            String className = parts[parts.length - 2];
            String methodName = parts[parts.length - 1];
            
            // 클래스명의 첫 글자 + 메서드명의 첫 3글자
            String classPrefix = className.length() > 0 ? className.substring(0, 1).toUpperCase() : "X";
            String methodPrefix = methodName.length() >= 3 ? methodName.substring(0, 3).toUpperCase() : methodName.toUpperCase();
            
            return classPrefix + methodPrefix;
        }
        
        // 해시 코드를 사용한 고유 접미사
        return String.valueOf(Math.abs(methodId.hashCode()) % 10000);
    }

    /**
     * AutoGeneratedTemplate을 ConditionTemplate 엔티티로 변환
     * 🔄 2단계: 자동 분류 시스템 적용
     */
    private ConditionTemplate convertToConditionTemplate(AutoGeneratedTemplate template) {
        ConditionTemplate entity = new ConditionTemplate();
        entity.setName(template.getName());
        entity.setDescription(template.getDescription());
        entity.setSpelTemplate(template.getSpelTemplate());
        entity.setIsAutoGenerated(true);
        entity.setTemplateType(template.getTemplateType());
        entity.setSourceMethod(template.getSourceMethod());
        entity.setIsUniversal(template.isUniversal());
        entity.setCreatedAt(LocalDateTime.now());
        entity.setUpdatedAt(LocalDateTime.now());
        
        // 🔄 2단계: 자동 생성 템플릿의 분류 결정
        if (template.isUniversal()) {
            // 범용 조건
            entity.setClassification(ConditionTemplate.ConditionClassification.UNIVERSAL);
            entity.setRiskLevel(ConditionTemplate.RiskLevel.LOW);
            entity.setComplexityScore(1);
            entity.setApprovalRequired(false);
            entity.setContextDependent(false);
        } else {
            // 템플릿 타입에 따른 분류
            switch (template.getTemplateType()) {
                case "object_return", "id_parameter", "ownership" -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.MEDIUM);
                    entity.setComplexityScore(calculateAutoTemplateComplexity(template.getSpelTemplate()));
                    entity.setApprovalRequired(false); // AI 검증만 필요
                    entity.setContextDependent(true);
                }
                case "self_check" -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.UNIVERSAL);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.LOW);
                    entity.setComplexityScore(2);
                    entity.setApprovalRequired(false);
                    entity.setContextDependent(false);
                }
                default -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.CUSTOM_COMPLEX);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.HIGH);
                    entity.setComplexityScore(calculateAutoTemplateComplexity(template.getSpelTemplate()));
                    entity.setApprovalRequired(true);
                    entity.setContextDependent(true);
                }
            }
        }
        
        return entity;
    }
    
    /**
     * 자동 생성 템플릿의 복잡도를 계산합니다.
     */
    private int calculateAutoTemplateComplexity(String spelTemplate) {
        if (spelTemplate == null) return 1;
        
        int score = 1;
        String spel = spelTemplate.toLowerCase();
        
        // hasPermission 사용 시 +2점
        if (spel.contains("haspermission")) score += 2;
        
        // 변수 개수에 따른 점수
        score += (spel.length() - spel.replace("#", "").length());
        
        // 논리 연산자
        if (spel.contains("&&") || spel.contains("||")) score += 1;
        
        return Math.min(score, 10);
    }

    /**
     * 🔧 개선: 중복을 제거하고 DB에 저장 (고유 이름 보장)
     * 이름과 SpEL 템플릿 모두 기준으로 중복 체크하며, 필요시 이름에 접미사 추가
     */
    @Transactional
    public List<ConditionTemplate> saveDedupedTemplates(List<ConditionTemplate> templates) {
        // 전체 기존 템플릿들 조회 (자동/수동 생성 모두)
        List<ConditionTemplate> allExistingTemplates = conditionTemplateRepository.findAll();
        
        // 중복 체크를 위한 Set 생성 (이름과 SpEL 템플릿 모두)
        Set<String> existingNames = allExistingTemplates.stream()
            .map(ConditionTemplate::getName)
            .collect(Collectors.toSet());
            
        Set<String> existingSpelTemplates = allExistingTemplates.stream()
            .map(ConditionTemplate::getSpelTemplate)
            .collect(Collectors.toSet());

        // 처리 중인 템플릿들의 이름도 추적 (배치 내에서 중복 방지)
        Set<String> processingNames = new HashSet<>();

        // 새 템플릿들을 필터링하고 중복 시 이름 수정
        List<ConditionTemplate> newTemplates = templates.stream()
            .filter(template -> {
                // SpEL 중복 체크 (SpEL이 중복되면 완전히 제외)
                if (existingSpelTemplates.contains(template.getSpelTemplate())) {
                    log.debug("⚠️ SpEL 중복으로 건너뜀: {} -> {}", template.getName(), template.getSpelTemplate());
                    return false;
                }
                
                // 이름 중복 체크 및 해결
                String originalName = template.getName();
                String uniqueName = makeUniqueName(originalName, existingNames, processingNames);
                
                if (!originalName.equals(uniqueName)) {
                    log.info("🔄 이름 중복 해결: '{}' -> '{}'", originalName, uniqueName);
                    template.setName(uniqueName);
                }
                
                // 처리 중인 이름에 추가
                processingNames.add(uniqueName);
                existingNames.add(uniqueName); // 다음 템플릿 처리 시 고려되도록
                
                return true;
            })
            .collect(Collectors.toList());

        log.info("💾 새로운 템플릿 저장: {} 개 (전체: {} 개, SpEL 중복 제외: {} 개)", 
            newTemplates.size(), templates.size(), templates.size() - newTemplates.size());

        return newTemplates.isEmpty() ? new ArrayList<>() : conditionTemplateRepository.saveAll(newTemplates);
    }

    /**
     * 🔧 고유한 이름 생성 (중복 시 접미사 추가)
     */
    private String makeUniqueName(String baseName, Set<String> existingNames, Set<String> processingNames) {
        if (!existingNames.contains(baseName) && !processingNames.contains(baseName)) {
            return baseName;
        }
        
        // 중복 시 접미사 추가 시도
        for (int i = 2; i <= 100; i++) {
            String candidateName = baseName + " (" + i + ")";
            if (!existingNames.contains(candidateName) && !processingNames.contains(candidateName)) {
                return candidateName;
            }
        }
        
        // 최후 수단: 타임스탬프 추가
        String timestampName = baseName + " (" + System.currentTimeMillis() % 10000 + ")";
        log.warn("⚠️ 고유 이름 생성을 위해 타임스탬프 사용: {}", timestampName);
        return timestampName;
    }

    /**
     * 🔧 통합: 리소스와 권한을 모두 고려한 통합 조건 템플릿 생성
     */
    @Transactional
    public List<ConditionTemplate> generateConditionTemplates() {
        log.info("🎯 AI 기반 METHOD 리소스 조건 템플릿 생성 시작");
        
        // ABAC는 서비스 레이어에서만 체크 - METHOD 타입 리소스만 대상
        List<ManagedResource> methodResources = managedResourceRepository.findAll()
            .stream()
            .filter(resource -> resource.getResourceType() == ManagedResource.ResourceType.METHOD)
            .filter(resource -> resource.getStatus() != ManagedResource.Status.EXCLUDED)
            .collect(Collectors.toList());
        
        if (methodResources.isEmpty()) {
            log.warn("⚠️ METHOD 타입 리소스가 없습니다. 조건 템플릿을 생성하지 않습니다.");
            return new ArrayList<>();
        }
        
        log.info("📋 AI 분석 대상 METHOD 리소스: {} 개", methodResources.size());
        
        List<ConditionTemplate> templates = new ArrayList<>();
        
        // 1. 범용 조건 템플릿 (AI로 생성)
        templates.addAll(generateAIUniversalTemplates());
        
        // 2. METHOD 리소스별 AI 특화 조건 템플릿  
        for (ManagedResource resource : methodResources) {
            try {
                templates.addAll(generateAISpecificTemplates(resource));
            } catch (Exception e) {
                log.warn("⚠️ AI 메서드 분석 실패: {} - {}", resource.getResourceIdentifier(), e.getMessage());
            }
        }
        
        // 중복 제거 및 저장
        List<ConditionTemplate> savedTemplates = saveDedupedTemplates(templates);
        
        log.info("🎉 AI 기반 조건 템플릿 생성 완료: {} 개", savedTemplates.size());
        return savedTemplates;
    }

    /**
     * AI를 통한 범용 조건 템플릿 생성
     */
    private List<ConditionTemplate> generateAIUniversalTemplates() {
        log.info("🤖 AI 범용 조건 템플릿 생성 시작");

        // 개선된 프롬프트 없이 바로 AINativeIAMAdvisor 호출
        String userPrompt = "서비스 레이어에서 정말 필요한 핵심 범용 조건 4-5개만 생성해주세요.";

        try {
            String aiResponse = callAI("", userPrompt);
            return parseAITemplateResponse(aiResponse, "범용");
        } catch (Exception e) {
            log.error("🔥 AI 범용 템플릿 생성 실패", e);
            return generateFallbackUniversalTemplates();
        }
    }

    /**
     * AI를 통한 특정 메서드별 조건 템플릿 생성
     */
    private List<ConditionTemplate> generateAISpecificTemplates(ManagedResource resource) {
        log.debug("🤖 AI 특화 조건 생성: {}", resource.getResourceIdentifier());

        String methodInfo = String.format("""
            메서드 정보:
            - 식별자: %s
            - 친화적 이름: %s
            - 설명: %s
            - 파라미터 타입: %s
            - 반환 타입: %s
            - 서비스 소유자: %s
            
            이 메서드에 대해 정확히 하나의 hasPermission() 조건만 생성하세요.
            메서드 이름과 파라미터를 정확히 분석하여 한국어 이름으로 만드세요.
            """,
            resource.getResourceIdentifier(),
            resource.getFriendlyName() != null ? resource.getFriendlyName() : "없음",
            resource.getDescription() != null ? resource.getDescription() : "없음",
            resource.getParameterTypes() != null ? resource.getParameterTypes() : "없음",
            resource.getReturnType() != null ? resource.getReturnType() : "void",
            resource.getServiceOwner() != null ? resource.getServiceOwner() : "알 수 없음");

        try {
            String aiResponse = callAI("", methodInfo);
            return parseAITemplateResponse(aiResponse, resource.getResourceIdentifier());
        } catch (Exception e) {
            log.warn("🔥 AI 특화 템플릿 생성 실패: {}", resource.getResourceIdentifier(), e);
            return new ArrayList<>();
        }
    }

    /**
     * AI 호출 헬퍼 메서드 - AINativeIAMAdvisor를 통한 실제 AI 호출
     */
    private String callAI(String systemPrompt, String userPrompt) {
        try {
            log.info("🤖 AINativeIAMAdvisor를 통한 AI 호출 시작");

            // 범용 조건인지 특화 조건인지 구분하여 적절한 메서드 호출
            if (userPrompt.contains("범용") || userPrompt.contains("업무 환경에서 자주 사용되는")) {
                log.info("🌐 범용 조건 템플릿 생성 요청");
                log.info("📝 범용 조건 입력: {}", userPrompt);
                String response = aiAdvisor.generateUniversalConditionTemplates();
                log.info("🤖 AI 범용 응답: {}", response);
                return response;
            } else {
                log.info("🎯 특화 조건 템플릿 생성 요청");
                log.info("📝 특화 조건 입력: {}", userPrompt);
                String response = aiAdvisor.generateSpecificConditionTemplates("METHOD", userPrompt);
                log.info("🤖 AI 특화 응답: {}", response);
                return response;
            }

        } catch (Exception e) {
            log.error("🔥 AINativeIAMAdvisor 호출 실패", e);
            // 폴백 제거 - AI 실패 시 빈 응답 반환
            return "[]";
        }
    }

    // 폴백 메서드 제거됨 - AI 응답만 분석

    /**
     * AI 응답을 ConditionTemplate 객체로 파싱
     */
    private List<ConditionTemplate> parseAITemplateResponse(String aiResponse, String sourceMethod) {
        List<ConditionTemplate> templates = new ArrayList<>();

        log.info("🔍 AI 응답 파싱 시작 - 소스: {}", sourceMethod);
        log.info("📄 원본 AI 응답: {}", aiResponse);

        try {
            // JSON 정제 - 마크다운 코드 블록 제거 및 불필요한 텍스트 제거
            String cleanedJson = extractAndCleanJson(aiResponse);
            log.info("🔍 정제된 JSON: {}", cleanedJson);

            // JSON 배열 파싱 시도
            List<Map<String, Object>> rawTemplates = objectMapper.readValue(
                cleanedJson, new TypeReference<List<Map<String, Object>>>() {});

            log.info("📊 파싱된 템플릿 개수: {} 개", rawTemplates.size());

            for (int i = 0; i < rawTemplates.size(); i++) {
                Map<String, Object> raw = rawTemplates.get(i);
                log.info("🎯 템플릿 {} 파싱: {}", i+1, raw);

                try {
                    ConditionTemplate template = ConditionTemplate.builder()
                        .name((String) raw.get("name"))
                        .description((String) raw.get("description"))
                        .spelTemplate((String) raw.get("spelTemplate"))
                        .category((String) raw.getOrDefault("category", "AI 생성"))
                        .classification(parseClassification((String) raw.get("classification")))
                        .sourceMethod(sourceMethod)
                        .isAutoGenerated(true)
                        .templateType("ai_generated")
                        .createdAt(LocalDateTime.now())
                        .build();

                    // SpEL 템플릿이 비어있지 않은 경우만 추가
                    if (template.getSpelTemplate() != null && !template.getSpelTemplate().trim().isEmpty()) {
                        templates.add(template);
                        log.info("✅ 템플릿 추가됨: {} - {}", template.getName(), template.getSpelTemplate());
                    } else {
                        log.warn("⚠️ 빈 SpEL 템플릿으로 인해 제외됨: {}", raw);
                    }
                } catch (Exception itemError) {
                    log.error("🔥 템플릿 항목 파싱 실패: {}", raw, itemError);
                }
            }

            log.info("✅ AI 응답 파싱 완료: {} 개 템플릿 최종 생성", templates.size());

        } catch (Exception e) {
            log.error("🔥 AI 응답 파싱 실패: {}", aiResponse, e);
            // 파싱 실패 시 빈 리스트 반환
        }

        return templates;
    }

    /**
     * AI 응답에서 JSON 부분만 추출하고 정제
     */
    private String extractAndCleanJson(String aiResponse) {
        if (aiResponse == null || aiResponse.trim().isEmpty()) {
            return "[]";
        }

        // 마크다운 코드 블록 제거
        String cleaned = aiResponse.replaceAll("```json\\s*", "").replaceAll("```\\s*", "");

        // JSON 배열 시작과 끝 찾기
        int startIdx = cleaned.indexOf('[');
        int endIdx = cleaned.lastIndexOf(']');

        if (startIdx != -1 && endIdx != -1 && startIdx < endIdx) {
            return cleaned.substring(startIdx, endIdx + 1).trim();
        }

        // JSON 객체 형태인 경우 배열로 감싸기
        startIdx = cleaned.indexOf('{');
        endIdx = cleaned.lastIndexOf('}');

        if (startIdx != -1 && endIdx != -1 && startIdx < endIdx) {
            String jsonObject = cleaned.substring(startIdx, endIdx + 1).trim();
            return "[" + jsonObject + "]";
        }

        // 파싱할 수 있는 JSON이 없으면 빈 배열 반환
        log.warn("🔥 AI 응답에서 유효한 JSON을 찾을 수 없음: {}", aiResponse.substring(0, Math.min(100, aiResponse.length())));
        return "[]";
    }

    private ConditionTemplate.ConditionClassification parseClassification(String classification) {
        if (classification == null) return ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT;

        try {
            return ConditionTemplate.ConditionClassification.valueOf(classification.toUpperCase());
        } catch (Exception e) {
            return ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT;
        }
    }

    /**
     * AI 실패 시 기본 범용 템플릿들
     */
    private List<ConditionTemplate> generateFallbackUniversalTemplates() {
        log.info("🔄 AI 실패로 인한 기본 범용 템플릿 생성");

        List<ConditionTemplate> templates = new ArrayList<>();

        // hasPermission 기반 권한 체크
        templates.add(ConditionTemplate.builder()
            .name("객체 읽기 권한")
            .description("메서드가 반환하는 객체에 대한 읽기 권한 확인")
            .category("권한 기반")
            .classification(ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT)
            .spelTemplate("hasPermission(#returnObject, 'READ')")
            .sourceMethod("기본")
            .isAutoGenerated(true)
            .templateType("fallback")
            .createdAt(LocalDateTime.now())
            .build());

        // Spring Security 기본 표현식
        templates.add(ConditionTemplate.builder()
            .name("인증 확인")
            .description("사용자가 인증되었는지 확인")
            .category("인증 기반")
            .classification(ConditionTemplate.ConditionClassification.UNIVERSAL)
            .spelTemplate("isAuthenticated()")
            .sourceMethod("기본")
            .isAutoGenerated(true)
            .templateType("fallback")
            .createdAt(LocalDateTime.now())
            .build());

        return templates;
    }

    private String generateFallbackUniversalResponse() {
        return """
        [
          {
            "name": "인증된 사용자 확인",
            "description": "사용자가 정상적으로 로그인되어 있는지 확인",
            "spelTemplate": "isAuthenticated()",
            "category": "인증 기반",
            "classification": "UNIVERSAL"
          },
          {
            "name": "완전 인증 확인", 
            "description": "Remember-me가 아닌 완전한 인증 확인",
            "spelTemplate": "isFullyAuthenticated()",
            "category": "인증 기반",
            "classification": "UNIVERSAL"
          },
          {
            "name": "업무시간 접근",
            "description": "오전 9시부터 오후 6시 사이에만 접근 허용",
            "spelTemplate": "T(java.time.LocalTime).now().hour >= 9 and T(java.time.LocalTime).now().hour < 18",
            "category": "시간 기반",
            "classification": "UNIVERSAL"
          },
          {
            "name": "반환 객체 읽기 권한",
            "description": "메서드가 반환하는 객체에 대한 읽기 권한",
            "spelTemplate": "hasPermission(#returnObject, 'READ')",
            "category": "권한 기반", 
            "classification": "CONTEXT_DEPENDENT"
          }
        ]
        """;
    }

    private String generateFallbackSpecificResponse(String methodInfo) {
        // 메서드 정보에서 간단한 패턴 추출
        if (methodInfo.contains("getDocument") || methodInfo.contains("Document")) {
            return """
            [
              {
                "name": "문서 조회 권한",
                "description": "특정 문서 ID에 대한 조회 권한 확인",
                "spelTemplate": "hasPermission(#id, 'DOCUMENT', 'READ')",
                "category": "권한 기반",
                "classification": "CONTEXT_DEPENDENT"
              }
            ]
            """;
        }

        return """
        [
          {
            "name": "기본 실행 권한",
            "description": "메서드 실행에 대한 기본 권한",
            "spelTemplate": "hasPermission(#id, 'RESOURCE', 'EXECUTE')",
            "category": "권한 기반", 
            "classification": "CONTEXT_DEPENDENT"
          }
        ]
        """;
    }
}