package io.spring.identityadmin.resource.service;

import io.spring.identityadmin.domain.entity.ConditionTemplate;
import io.spring.identityadmin.domain.entity.ManagedResource;
import io.spring.identityadmin.domain.entity.Permission;
import io.spring.identityadmin.repository.ConditionTemplateRepository;
import io.spring.identityadmin.repository.ManagedResourceRepository;
import io.spring.identityadmin.repository.PermissionRepository;
import io.spring.identityadmin.resource.MethodPatternAnalyzer;
import io.spring.identityadmin.resource.MethodPatternAnalyzer.MethodAnalysisResult;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AutoConditionTemplateService {

    private final ConditionTemplateRepository conditionTemplateRepository;
    private final MethodPatternAnalyzer methodPatternAnalyzer;
    private final PermissionRepository permissionRepository;
    private final ManagedResourceRepository managedResourceRepository;

    /**
     * 자동 생성된 조건 템플릿 정보를 담는 DTO
     */
    public static class AutoGeneratedTemplate {
        private String name;
        private String description;
        private String spelTemplate;
        private String templateType;
        private String sourceMethod;
        private boolean isUniversal;
        private Map<String, Object> metadata;

        // 생성자, getter, setter
        public AutoGeneratedTemplate(String name, String description, String spelTemplate, 
                                   String templateType, String sourceMethod, boolean isUniversal) {
            this.name = name;
            this.description = description;
            this.spelTemplate = spelTemplate;
            this.templateType = templateType;
            this.sourceMethod = sourceMethod;
            this.isUniversal = isUniversal;
            this.metadata = new HashMap<>();
        }

        // Getters and Setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        public String getSpelTemplate() { return spelTemplate; }
        public void setSpelTemplate(String spelTemplate) { this.spelTemplate = spelTemplate; }
        public String getTemplateType() { return templateType; }
        public void setTemplateType(String templateType) { this.templateType = templateType; }
        public String getSourceMethod() { return sourceMethod; }
        public void setSourceMethod(String sourceMethod) { this.sourceMethod = sourceMethod; }
        public boolean isUniversal() { return isUniversal; }
        public void setUniversal(boolean universal) { isUniversal = universal; }
        public Map<String, Object> getMetadata() { return metadata; }
        public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    }

    /**
     * 메서드 분석 결과를 바탕으로 조건 템플릿을 자동 생성합니다.
     */
    @Transactional
    public List<ConditionTemplate> generateTemplatesFromAnalysis(List<MethodAnalysisResult> analysisResults) {
        log.info("🔄 자동 조건 템플릿 생성 시작: {} 개 분석 결과", analysisResults.size());

        List<ConditionTemplate> generatedTemplates = new ArrayList<>();

        // 1. 범용 조건 템플릿 생성 (한 번만)
        List<ConditionTemplate> universalTemplates = generateUniversalTemplates();
        generatedTemplates.addAll(universalTemplates);

        // 2. 메서드별 특화 템플릿 생성
        for (MethodAnalysisResult analysis : analysisResults) {
            List<ConditionTemplate> methodTemplates = generateMethodSpecificTemplates(analysis);
            generatedTemplates.addAll(methodTemplates);
        }

        // 3. 중복 제거 및 DB 저장
        List<ConditionTemplate> savedTemplates = saveDedupedTemplates(generatedTemplates);

        log.info("✅ 자동 조건 템플릿 생성 완료: {} 개 템플릿 저장", savedTemplates.size());
        return savedTemplates;
    }

    /**
     * 범용 조건 템플릿들을 생성합니다.
     */
    private List<ConditionTemplate> generateUniversalTemplates() {
        List<AutoGeneratedTemplate> universalTemplates = Arrays.asList(
            // 시간 기반 조건들
            new AutoGeneratedTemplate(
                "업무시간 접근",
                "평일 오전 9시부터 오후 6시까지만 접근 허용",
                "T(java.time.LocalTime).now().hour >= 9 and T(java.time.LocalTime).now().hour <= 18",
                "universal", "system_generated", true),
            
            new AutoGeneratedTemplate(
                "평일 접근",
                "월요일부터 금요일까지만 접근 허용",
                "T(java.time.LocalDate).now().dayOfWeek.value <= 5",
                "universal", "system_generated", true),

            // IP 기반 조건들
            new AutoGeneratedTemplate(
                "내부망 접근",
                "192.168.x.x 대역에서만 접근 허용",
                "#request.remoteAddr matches '^192\\\\.168\\\\..*'",
                "universal", "system_generated", true),

            new AutoGeneratedTemplate(
                "사내망 접근",
                "10.x.x.x 대역에서만 접근 허용",
                "#request.remoteAddr matches '^10\\\\..*'",
                "universal", "system_generated", true),

            // 역할 기반 조건들
            new AutoGeneratedTemplate(
                "관리자 권한",
                "ADMIN 역할을 가진 사용자만 접근 허용",
                "hasRole('ADMIN')",
                "universal", "system_generated", true),

            new AutoGeneratedTemplate(
                "매니저 권한",
                "MANAGER 역할을 가진 사용자만 접근 허용",
                "hasRole('MANAGER')",
                "universal", "system_generated", true),

            new AutoGeneratedTemplate(
                "시스템 관리자",
                "SYSTEM_ADMIN 권한을 가진 사용자만 접근 허용",
                "hasAuthority('SYSTEM_ADMIN')",
                "universal", "system_generated", true)
        );

        return universalTemplates.stream()
            .map(this::convertToConditionTemplate)
            .collect(Collectors.toList());
    }

    /**
     * 특정 메서드에 대한 조건 템플릿들을 생성합니다.
     */
    private List<ConditionTemplate> generateMethodSpecificTemplates(MethodAnalysisResult analysis) {
        List<AutoGeneratedTemplate> templates = new ArrayList<>();

        switch (analysis.getDetectedPattern()) {
            case OBJECT_RETURN_PATTERN:
                templates.addAll(generateObjectReturnTemplates(analysis));
                break;
            case ID_PARAMETER_PATTERN:
                templates.addAll(generateIdParameterTemplates(analysis));
                break;
            case UNIVERSAL_PATTERN:
                // 범용 패턴은 이미 처리됨
                break;
            default:
                log.debug("지원하지 않는 패턴으로 템플릿 생성 스킵: {}", analysis.getDetectedPattern());
        }

        return templates.stream()
            .map(this::convertToConditionTemplate)
            .collect(Collectors.toList());
    }

    /**
     * 객체 반환 패턴 템플릿 생성
     */
    private List<AutoGeneratedTemplate> generateObjectReturnTemplates(MethodAnalysisResult analysis) {
        String entityType = (String) analysis.getMetadata().get("entityType");
        String methodId = analysis.getMethodIdentifier();

        // 🔄 개선: 한국어 친화적인 조건명 생성
        String koreanEntityName = getKoreanEntityName(entityType);
        String methodName = extractMethodName(methodId);

        return Arrays.asList(
            new AutoGeneratedTemplate(
                String.format("%s 조회 후 접근 권한", koreanEntityName),
                String.format("조회된 %s에 대한 접근 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "hasPermission(#returnObject, 'READ')",
                "object_return", methodId, false),

            new AutoGeneratedTemplate(
                String.format("%s 조회 후 수정 권한", koreanEntityName),
                String.format("조회된 %s에 대한 수정 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "hasPermission(#returnObject, 'UPDATE')",
                "object_return", methodId, false),

            new AutoGeneratedTemplate(
                String.format("%s 조회 후 삭제 권한", koreanEntityName),
                String.format("조회된 %s에 대한 삭제 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "hasPermission(#returnObject, 'DELETE')",
                "object_return", methodId, false),

            new AutoGeneratedTemplate(
                String.format("%s 소유자 여부 확인", koreanEntityName),
                String.format("조회된 %s의 소유자인지 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "#returnObject.owner == #authentication.name",
                "ownership", methodId, false),

            new AutoGeneratedTemplate(
                String.format("%s 생성자 여부 확인", koreanEntityName),
                String.format("조회된 %s의 생성자인지 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                "#returnObject.createdBy == #authentication.name",
                "ownership", methodId, false)
        );
    }

    /**
     * ID 파라미터 패턴 템플릿 생성
     */
    private List<AutoGeneratedTemplate> generateIdParameterTemplates(MethodAnalysisResult analysis) {
        String entityType = (String) analysis.getMetadata().get("entityType");
        String idParamName = (String) analysis.getMetadata().get("idParameterName");
        String methodId = analysis.getMethodIdentifier();

        List<AutoGeneratedTemplate> templates = new ArrayList<>();

        // 🔄 개선: 실제 권한명과 연관성을 높이는 조건명 생성
        String koreanEntityName = getKoreanEntityName(entityType);
        String methodName = extractMethodName(methodId);
        String actionType = extractActionFromMethod(methodName);

        templates.add(new AutoGeneratedTemplate(
            String.format("%s %s 권한 확인", koreanEntityName, actionType),
            String.format("ID로 %s %s 권한을 확인합니다 [메서드: %s]", koreanEntityName, actionType, methodName),
            String.format("hasPermission(#%s, '%s', 'UPDATE')", idParamName, entityType),
            "id_parameter", methodId, false));

        templates.add(new AutoGeneratedTemplate(
            String.format("%s 삭제 권한 확인", koreanEntityName),
            String.format("ID로 %s 삭제 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
            String.format("hasPermission(#%s, '%s', 'DELETE')", idParamName, entityType),
            "id_parameter", methodId, false));

        // User 엔티티의 경우 자기 자신 체크 추가
        if ("User".equals(entityType)) {
            templates.add(new AutoGeneratedTemplate(
                String.format("본인 %s 확인", actionType),
                String.format("요청한 사용자가 본인인지 확인합니다 [메서드: %s]", methodName),
                String.format("#%s == #authentication.id", idParamName),
                "self_check", methodId, false));
        }

        return templates;
    }

    /**
     * 🔄 개선: 엔티티 타입을 한국어로 변환
     */
    private String getKoreanEntityName(String entityType) {
        if (entityType == null) return "리소스";
        
        Map<String, String> entityNames = Map.of(
            "User", "사용자",
            "Document", "문서", 
            "Group", "그룹",
            "Role", "역할",
            "Permission", "권한",
            "Policy", "정책",
            "Resource", "리소스",
            "File", "파일",
            "Project", "프로젝트",
            "Organization", "조직"
        );
        
        return entityNames.getOrDefault(entityType, entityType.toLowerCase());
    }

    /**
     * 🔄 개선: 메서드명에서 액션 타입 추출
     */
    private String extractActionFromMethod(String methodName) {
        if (methodName == null) return "처리";
        
        String lowerMethod = methodName.toLowerCase();
        
        if (lowerMethod.contains("update") || lowerMethod.contains("modify") || lowerMethod.contains("edit")) {
            return "수정";
        } else if (lowerMethod.contains("delete") || lowerMethod.contains("remove")) {
            return "삭제";
        } else if (lowerMethod.contains("create") || lowerMethod.contains("add") || lowerMethod.contains("insert")) {
            return "생성";
        } else if (lowerMethod.contains("read") || lowerMethod.contains("get") || lowerMethod.contains("find") || lowerMethod.contains("view")) {
            return "조회";
        } else if (lowerMethod.contains("approve")) {
            return "승인";
        } else if (lowerMethod.contains("reject")) {
            return "거부";
        } else if (lowerMethod.contains("assign")) {
            return "할당";
        } else if (lowerMethod.contains("revoke")) {
            return "취소";
        }
        
        return "처리";
    }

    /**
     * 🔄 개선: 메서드 ID에서 메서드명만 추출
     */
    private String extractMethodName(String methodId) {
        if (methodId == null) return "unknown";
        
        String[] parts = methodId.split("\\.");
        return parts.length > 0 ? parts[parts.length - 1] : methodId;
    }
    
    /**
     * 메서드 ID에서 고유한 접미사를 생성합니다.
     */
    private String generateMethodSuffix(String methodId) {
        // 메서드 ID에서 클래스명과 메서드명을 추출하여 짧은 접미사 생성
        if (methodId == null) return "AUTO";
        
        String[] parts = methodId.split("\\.");
        if (parts.length >= 2) {
            String className = parts[parts.length - 2];
            String methodName = parts[parts.length - 1];
            
            // 클래스명의 첫 글자 + 메서드명의 첫 3글자
            String classPrefix = className.length() > 0 ? className.substring(0, 1).toUpperCase() : "X";
            String methodPrefix = methodName.length() >= 3 ? methodName.substring(0, 3).toUpperCase() : methodName.toUpperCase();
            
            return classPrefix + methodPrefix;
        }
        
        // 해시 코드를 사용한 고유 접미사
        return String.valueOf(Math.abs(methodId.hashCode()) % 10000);
    }

    /**
     * AutoGeneratedTemplate을 ConditionTemplate 엔티티로 변환
     * 🔄 2단계: 자동 분류 시스템 적용
     */
    private ConditionTemplate convertToConditionTemplate(AutoGeneratedTemplate template) {
        ConditionTemplate entity = new ConditionTemplate();
        entity.setName(template.getName());
        entity.setDescription(template.getDescription());
        entity.setSpelTemplate(template.getSpelTemplate());
        entity.setIsAutoGenerated(true);
        entity.setTemplateType(template.getTemplateType());
        entity.setSourceMethod(template.getSourceMethod());
        entity.setIsUniversal(template.isUniversal());
        entity.setCreatedAt(LocalDateTime.now());
        entity.setUpdatedAt(LocalDateTime.now());
        
        // 🔄 2단계: 자동 생성 템플릿의 분류 결정
        if (template.isUniversal()) {
            // 범용 조건
            entity.setClassification(ConditionTemplate.ConditionClassification.UNIVERSAL);
            entity.setRiskLevel(ConditionTemplate.RiskLevel.LOW);
            entity.setComplexityScore(1);
            entity.setApprovalRequired(false);
            entity.setContextDependent(false);
        } else {
            // 템플릿 타입에 따른 분류
            switch (template.getTemplateType()) {
                case "object_return", "id_parameter", "ownership" -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.MEDIUM);
                    entity.setComplexityScore(calculateAutoTemplateComplexity(template.getSpelTemplate()));
                    entity.setApprovalRequired(false); // AI 검증만 필요
                    entity.setContextDependent(true);
                }
                case "self_check" -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.UNIVERSAL);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.LOW);
                    entity.setComplexityScore(2);
                    entity.setApprovalRequired(false);
                    entity.setContextDependent(false);
                }
                default -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.CUSTOM_COMPLEX);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.HIGH);
                    entity.setComplexityScore(calculateAutoTemplateComplexity(template.getSpelTemplate()));
                    entity.setApprovalRequired(true);
                    entity.setContextDependent(true);
                }
            }
        }
        
        return entity;
    }
    
    /**
     * 자동 생성 템플릿의 복잡도를 계산합니다.
     */
    private int calculateAutoTemplateComplexity(String spelTemplate) {
        if (spelTemplate == null) return 1;
        
        int score = 1;
        String spel = spelTemplate.toLowerCase();
        
        // hasPermission 사용 시 +2점
        if (spel.contains("haspermission")) score += 2;
        
        // 변수 개수에 따른 점수
        score += (spel.length() - spel.replace("#", "").length());
        
        // 논리 연산자
        if (spel.contains("&&") || spel.contains("||")) score += 1;
        
        return Math.min(score, 10);
    }

    /**
     * 🔧 개선: 중복을 제거하고 DB에 저장 (고유 이름 보장)
     * 이름과 SpEL 템플릿 모두 기준으로 중복 체크하며, 필요시 이름에 접미사 추가
     */
    @Transactional
    private List<ConditionTemplate> saveDedupedTemplates(List<ConditionTemplate> templates) {
        // 전체 기존 템플릿들 조회 (자동/수동 생성 모두)
        List<ConditionTemplate> allExistingTemplates = conditionTemplateRepository.findAll();
        
        // 중복 체크를 위한 Set 생성 (이름과 SpEL 템플릿 모두)
        Set<String> existingNames = allExistingTemplates.stream()
            .map(ConditionTemplate::getName)
            .collect(Collectors.toSet());
            
        Set<String> existingSpelTemplates = allExistingTemplates.stream()
            .map(ConditionTemplate::getSpelTemplate)
            .collect(Collectors.toSet());

        // 처리 중인 템플릿들의 이름도 추적 (배치 내에서 중복 방지)
        Set<String> processingNames = new HashSet<>();

        // 새 템플릿들을 필터링하고 중복 시 이름 수정
        List<ConditionTemplate> newTemplates = templates.stream()
            .filter(template -> {
                // SpEL 중복 체크 (SpEL이 중복되면 완전히 제외)
                if (existingSpelTemplates.contains(template.getSpelTemplate())) {
                    log.debug("⚠️ SpEL 중복으로 건너뜀: {} -> {}", template.getName(), template.getSpelTemplate());
                    return false;
                }
                
                // 이름 중복 체크 및 해결
                String originalName = template.getName();
                String uniqueName = makeUniqueName(originalName, existingNames, processingNames);
                
                if (!originalName.equals(uniqueName)) {
                    log.info("🔄 이름 중복 해결: '{}' -> '{}'", originalName, uniqueName);
                    template.setName(uniqueName);
                }
                
                // 처리 중인 이름에 추가
                processingNames.add(uniqueName);
                existingNames.add(uniqueName); // 다음 템플릿 처리 시 고려되도록
                
                return true;
            })
            .collect(Collectors.toList());

        log.info("💾 새로운 템플릿 저장: {} 개 (전체: {} 개, SpEL 중복 제외: {} 개)", 
            newTemplates.size(), templates.size(), templates.size() - newTemplates.size());

        return newTemplates.isEmpty() ? new ArrayList<>() : conditionTemplateRepository.saveAll(newTemplates);
    }

    /**
     * 🔧 고유한 이름 생성 (중복 시 접미사 추가)
     */
    private String makeUniqueName(String baseName, Set<String> existingNames, Set<String> processingNames) {
        if (!existingNames.contains(baseName) && !processingNames.contains(baseName)) {
            return baseName;
        }
        
        // 중복 시 접미사 추가 시도
        for (int i = 2; i <= 100; i++) {
            String candidateName = baseName + " (" + i + ")";
            if (!existingNames.contains(candidateName) && !processingNames.contains(candidateName)) {
                return candidateName;
            }
        }
        
        // 최후 수단: 타임스탬프 추가
        String timestampName = baseName + " (" + System.currentTimeMillis() % 10000 + ")";
        log.warn("⚠️ 고유 이름 생성을 위해 타임스탬프 사용: {}", timestampName);
        return timestampName;
    }

    /**
     * 🚀 개선: ManagedResource 기반 조건 템플릿 생성
     * ManagedResource의 friendlyName을 기반으로 조건명을 생성하여 매칭 문제 해결
     */
    @Transactional
    public List<ConditionTemplate> generateManagedResourceBasedTemplates() {
        log.info("🎯 ManagedResource 기반 조건 템플릿 생성 시작");
        
        // 관리 대상인 모든 리소스 조회 (EXCLUDED 상태 제외)
        List<ManagedResource> managedResources = managedResourceRepository.findByStatusInWithPermission(
            Arrays.asList(
                ManagedResource.Status.NEEDS_DEFINITION,
                ManagedResource.Status.PERMISSION_CREATED,
                ManagedResource.Status.POLICY_CONNECTED
            )
        );
        log.info("📋 관리 대상 리소스 수: {} 개", managedResources.size());
        
        List<ConditionTemplate> generatedTemplates = new ArrayList<>();
        
        for (ManagedResource resource : managedResources) {
            List<ConditionTemplate> resourceTemplates = generateTemplatesForManagedResource(resource);
            generatedTemplates.addAll(resourceTemplates);
        }
        
        // 중복 제거 및 저장
        List<ConditionTemplate> savedTemplates = saveDedupedTemplates(generatedTemplates);
        
        log.info("✅ ManagedResource 기반 조건 템플릿 생성 완료: {} 개 저장", savedTemplates.size());
        return savedTemplates;
    }

    /**
     * 🚀 개선: Permission 기반 조건 템플릿 생성
     * 실제 권한명(friendlyName)을 기반으로 조건명을 생성하여 매칭 문제 해결
     */
    @Transactional
    public List<ConditionTemplate> generatePermissionBasedTemplates() {
        log.info("🎯 Permission 기반 조건 템플릿 생성 시작");
        
        // 정의된 모든 권한 조회
        List<Permission> allPermissions = permissionRepository.findDefinedPermissionsWithDetails();
        log.info("📋 정의된 권한 수: {} 개", allPermissions.size());
        
        List<ConditionTemplate> generatedTemplates = new ArrayList<>();
        
        for (Permission permission : allPermissions) {
            List<ConditionTemplate> permissionTemplates = generateTemplatesForPermission(permission);
            generatedTemplates.addAll(permissionTemplates);
        }
        
        // 중복 제거 및 저장
        List<ConditionTemplate> savedTemplates = saveDedupedTemplates(generatedTemplates);
        
        log.info("✅ Permission 기반 조건 템플릿 생성 완료: {} 개 저장", savedTemplates.size());
        return savedTemplates;
    }

    /**
     * 특정 ManagedResource에 대한 조건 템플릿들 생성
     */
    private List<ConditionTemplate> generateTemplatesForManagedResource(ManagedResource resource) {
        List<AutoGeneratedTemplate> templates = new ArrayList<>();
        
        String friendlyName = resource.getFriendlyName();
        String resourceIdentifier = resource.getResourceIdentifier();
        String resourceType = resource.getResourceType().name();
        
        // friendlyName이 없으면 resourceIdentifier에서 추출
        String displayName = (friendlyName != null && !friendlyName.trim().isEmpty()) 
            ? friendlyName : extractFriendlyNameFromIdentifier(resourceIdentifier);
        
        log.debug("🔄 조건 생성 중: {} ({})", displayName, resourceIdentifier);
        
        // 기본 접근 권한 확인
        templates.add(new AutoGeneratedTemplate(
            String.format("%s 접근 권한", displayName),
            String.format("'%s' 기능에 대한 접근 권한을 확인합니다", displayName),
            String.format("hasAuthority('%s')", generatePermissionNameFromResource(resource)),
            "resource_access", resourceIdentifier, false));
        
        // 역할 기반 접근 (특정 키워드가 포함된 경우)
        if (containsAdminKeywords(displayName)) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s 관리자 권한", displayName),
                String.format("'%s' 기능에 대한 관리자 권한을 확인합니다", displayName),
                "hasRole('ADMIN')",
                "admin_access", resourceIdentifier, false));
        }
        
        if (containsManagerKeywords(displayName)) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s 매니저 권한", displayName),
                String.format("'%s' 기능에 대한 매니저 권한을 확인합니다", displayName),
                "hasRole('MANAGER')",
                "manager_access", resourceIdentifier, false));
        }
        
        // 메서드 타입인 경우 객체 레벨 권한 체크
        if (resource.getResourceType() == ManagedResource.ResourceType.METHOD) {
            String actionType = extractActionFromResourceName(displayName);
            if (actionType != null) {
                templates.add(new AutoGeneratedTemplate(
                    String.format("%s 객체 권한", displayName),
                    String.format("특정 객체에 대한 %s 권한을 확인합니다", actionType),
                    String.format("hasPermission(#targetObject, '%s')", actionType.toUpperCase()),
                    "object_level", resourceIdentifier, false));
            }
        }
        
        // 중요한 작업에 대한 시간 제한 (생성, 수정, 삭제)
        if (containsImportantActions(displayName)) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s + 업무시간 제한", displayName),
                String.format("'%s' 작업은 업무시간에만 허용됩니다", displayName),
                String.format("hasAuthority('%s') && T(java.time.LocalTime).now().hour >= 9 && T(java.time.LocalTime).now().hour <= 18", 
                    generatePermissionNameFromResource(resource)),
                "time_restricted", resourceIdentifier, false));
        }
        
        // IP 제한이 필요한 민감한 작업
        if (containsSensitiveKeywords(displayName)) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s + 내부망 제한", displayName),
                String.format("'%s' 작업은 내부망에서만 허용됩니다", displayName),
                String.format("hasAuthority('%s') && #request.remoteAddr matches '^192\\\\.168\\\\..*'", 
                    generatePermissionNameFromResource(resource)),
                "ip_restricted", resourceIdentifier, false));
        }
        
        return templates.stream()
            .map(this::convertToConditionTemplate)
            .collect(Collectors.toList());
    }

    /**
     * 특정 Permission에 대한 조건 템플릿들 생성
     */
    private List<ConditionTemplate> generateTemplatesForPermission(Permission permission) {
        List<AutoGeneratedTemplate> templates = new ArrayList<>();
        
        String friendlyName = permission.getFriendlyName();
        String targetType = permission.getTargetType();
        String actionType = permission.getActionType();
        String permissionName = permission.getName();
        
        // friendlyName이 없으면 name 사용
        String displayName = (friendlyName != null && !friendlyName.trim().isEmpty()) 
            ? friendlyName : permissionName;
        
        log.debug("🔄 조건 생성 중: {} ({})", displayName, permissionName);
        
        // 기본 권한 확인 조건
        templates.add(new AutoGeneratedTemplate(
            String.format("%s 권한 확인", displayName),
            String.format("'%s' 권한을 보유하고 있는지 확인합니다", displayName),
            String.format("hasAuthority('%s')", permissionName),
            "permission_check", permissionName, false));
        
        // 역할 기반 권한 확인 (권한명에 ROLE이 포함된 경우)
        if (permissionName.toUpperCase().contains("ROLE") || 
            (displayName != null && displayName.contains("역할"))) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s 역할 확인", displayName),
                String.format("'%s' 역할을 보유하고 있는지 확인합니다", displayName),
                String.format("hasRole('%s')", permissionName.replace("ROLE_", "")),
                "role_check", permissionName, false));
        }
        
        // targetType과 actionType이 있는 경우 객체 레벨 권한 확인
        if (targetType != null && actionType != null) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s 객체 권한 확인", displayName),
                String.format("특정 %s 객체에 대한 %s 권한을 확인합니다", 
                    getKoreanEntityName(targetType), getKoreanActionName(actionType)),
                String.format("hasPermission(#targetObject, '%s')", actionType),
                "object_permission", permissionName, false));
        }
        
        // 관리자 권한이 포함된 경우
        if (displayName != null && (displayName.contains("관리") || displayName.contains("admin"))) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s + 관리자 확인", displayName),
                String.format("'%s' 권한과 관리자 역할을 모두 확인합니다", displayName),
                String.format("hasAuthority('%s') && hasRole('ADMIN')", permissionName),
                "admin_permission", permissionName, false));
        }
        
        // 시간 제한이 필요할 수 있는 권한들 (생성, 수정, 삭제)
        if (actionType != null && (actionType.contains("CREATE") || actionType.contains("UPDATE") || actionType.contains("DELETE")) ||
            displayName != null && (displayName.contains("생성") || displayName.contains("수정") || displayName.contains("삭제"))) {
            templates.add(new AutoGeneratedTemplate(
                String.format("%s + 업무시간 제한", displayName),
                String.format("'%s' 권한과 업무시간 제한을 함께 확인합니다", displayName),
                String.format("hasAuthority('%s') && T(java.time.LocalTime).now().hour >= 9 && T(java.time.LocalTime).now().hour <= 18", permissionName),
                "time_restricted_permission", permissionName, false));
        }
        
        return templates.stream()
            .map(this::convertToConditionTemplate)
            .collect(Collectors.toList());
    }

    /**
     * 액션 타입을 한국어로 변환
     */
    private String getKoreanActionName(String actionType) {
        if (actionType == null) return "처리";
        
        Map<String, String> actionNames = Map.of(
            "READ", "조회",
            "CREATE", "생성", 
            "UPDATE", "수정",
            "DELETE", "삭제",
            "EXECUTE", "실행",
            "APPROVE", "승인",
            "REJECT", "거부"
        );
        
        return actionNames.getOrDefault(actionType.toUpperCase(), actionType.toLowerCase());
    }

    /**
     * 기존 자동 생성 템플릿들을 모두 제거하고 새로 생성
     */
    @Transactional
    public List<ConditionTemplate> regenerateAllTemplates(List<MethodAnalysisResult> analysisResults) {
        log.info("🔄 기존 자동 생성 템플릿 제거 및 재생성 시작");

        // 기존 자동 생성 템플릿들 삭제
        conditionTemplateRepository.deleteByIsAutoGenerated(true);

        // 새로 생성
        return generateTemplatesFromAnalysis(analysisResults);
    }

    /**
     * 특정 메서드에 대한 템플릿들만 갱신
     */
    @Transactional
    public List<ConditionTemplate> updateTemplatesForMethod(MethodAnalysisResult analysis) {
        log.info("🔄 메서드별 템플릿 갱신: {}", analysis.getMethodIdentifier());

        // 해당 메서드의 기존 템플릿들 삭제
        conditionTemplateRepository.deleteBySourceMethod(analysis.getMethodIdentifier());

        // 새 템플릿들 생성
        List<ConditionTemplate> methodTemplates = generateMethodSpecificTemplates(analysis);
        
        return conditionTemplateRepository.saveAll(methodTemplates);
    }

    /**
     * resourceIdentifier에서 친화적인 이름을 추출
     */
    private String extractFriendlyNameFromIdentifier(String resourceIdentifier) {
        if (resourceIdentifier == null || resourceIdentifier.trim().isEmpty()) {
            return "미정의 리소스";
        }
        
        // URL 패턴인 경우
        if (resourceIdentifier.startsWith("/")) {
            String[] segments = resourceIdentifier.split("/");
            String lastSegment = segments[segments.length - 1];
            return lastSegment.isEmpty() ? segments[segments.length - 2] : lastSegment;
        }
        
        // 메서드 패턴인 경우 (io.spring.identityadmin.service.UserService.updateUser)
        if (resourceIdentifier.contains(".")) {
            String[] parts = resourceIdentifier.split("\\.");
            String methodPart = parts[parts.length - 1];
            
            // 메서드명에서 파라미터 제거 (updateUser(Long) -> updateUser)
            if (methodPart.contains("(")) {
                methodPart = methodPart.substring(0, methodPart.indexOf("("));
            }
            
            return camelCaseToKorean(methodPart);
        }
        
        return resourceIdentifier;
    }
    
    /**
     * camelCase를 한국어 친화적으로 변환
     */
    private String camelCaseToKorean(String camelCase) {
        if (camelCase == null || camelCase.isEmpty()) {
            return camelCase;
        }
        
        // 일반적인 액션 패턴 매핑
        Map<String, String> actionMappings = Map.of(
            "get", "조회",
            "find", "검색",
            "create", "생성",
            "add", "추가",
            "update", "수정",
            "modify", "변경",
            "delete", "삭제",
            "remove", "제거",
            "save", "저장",
            "load", "로드"
        );
        
        // 엔티티 패턴 매핑
        Map<String, String> entityMappings = Map.of(
            "User", "사용자",
            "Document", "문서",
            "Group", "그룹",
            "Role", "역할",
            "Permission", "권한",
            "Policy", "정책"
        );
        
        StringBuilder result = new StringBuilder();
        String[] words = camelCase.split("(?=[A-Z])");
        
        for (String word : words) {
            if (word.isEmpty()) continue;
            
            String lowerWord = word.toLowerCase();
            if (actionMappings.containsKey(lowerWord)) {
                result.append(actionMappings.get(lowerWord));
            } else if (entityMappings.containsKey(word)) {
                result.append(entityMappings.get(word));
            } else {
                result.append(word);
            }
            result.append(" ");
        }
        
        return result.toString().trim();
    }
    
    /**
     * ManagedResource로부터 권한명 생성
     */
    private String generatePermissionNameFromResource(ManagedResource resource) {
        if (resource.getPermission() != null && resource.getPermission().getName() != null) {
            return resource.getPermission().getName();
        }
        
        // 권한이 없는 경우 리소스 식별자 기반으로 생성
        String resourceType = resource.getResourceType().name();
        String identifier = resource.getResourceIdentifier()
            .replaceAll("[^a-zA-Z0-9]", "_")
            .toUpperCase();
        
        return String.format("%s_%s", resourceType, identifier);
    }
    
    /**
     * 관리자 키워드 포함 여부 확인
     */
    private boolean containsAdminKeywords(String text) {
        if (text == null) return false;
        String lowerText = text.toLowerCase();
        return lowerText.contains("관리") || lowerText.contains("admin") || 
               lowerText.contains("시스템") || lowerText.contains("설정");
    }
    
    /**
     * 매니저 키워드 포함 여부 확인
     */
    private boolean containsManagerKeywords(String text) {
        if (text == null) return false;
        String lowerText = text.toLowerCase();
        return lowerText.contains("매니저") || lowerText.contains("manager") ||
               lowerText.contains("팀장") || lowerText.contains("승인");
    }
    
    /**
     * 리소스명에서 액션 타입 추출
     */
    private String extractActionFromResourceName(String resourceName) {
        if (resourceName == null) return null;
        
        String lowerName = resourceName.toLowerCase();
        
        if (lowerName.contains("조회") || lowerName.contains("get") || lowerName.contains("find")) {
            return "read";
        } else if (lowerName.contains("생성") || lowerName.contains("create") || lowerName.contains("add")) {
            return "create";
        } else if (lowerName.contains("수정") || lowerName.contains("update") || lowerName.contains("modify")) {
            return "update";
        } else if (lowerName.contains("삭제") || lowerName.contains("delete") || lowerName.contains("remove")) {
            return "delete";
        } else if (lowerName.contains("실행") || lowerName.contains("execute")) {
            return "execute";
        }
        
        return null;
    }
    
    /**
     * 중요한 작업 키워드 포함 여부 확인 (시간 제한 필요)
     */
    private boolean containsImportantActions(String text) {
        if (text == null) return false;
        String lowerText = text.toLowerCase();
        return lowerText.contains("생성") || lowerText.contains("create") ||
               lowerText.contains("수정") || lowerText.contains("update") ||
               lowerText.contains("삭제") || lowerText.contains("delete") ||
               lowerText.contains("승인") || lowerText.contains("approve");
    }
    
    /**
     * 민감한 작업 키워드 포함 여부 확인 (IP 제한 필요)
     */
    private boolean containsSensitiveKeywords(String text) {
        if (text == null) return false;
        String lowerText = text.toLowerCase();
        return lowerText.contains("시스템") || lowerText.contains("system") ||
               lowerText.contains("설정") || lowerText.contains("config") ||
               lowerText.contains("권한") || lowerText.contains("permission") ||
               lowerText.contains("정책") || lowerText.contains("policy");
    }

    /**
     * Repository 접근을 위한 getter 메서드
     */
    public ConditionTemplateRepository getConditionTemplateRepository() {
        return conditionTemplateRepository;
    }
} 