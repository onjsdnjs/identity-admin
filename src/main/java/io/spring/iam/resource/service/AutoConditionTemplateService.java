package io.spring.iam.resource.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.spring.iam.aiam.AINativeIAMAdvisor;
import io.spring.iam.domain.dto.AutoGeneratedTemplate;
import io.spring.iam.domain.entity.ConditionTemplate;
import io.spring.iam.domain.entity.ManagedResource;
import io.spring.iam.repository.ConditionTemplateRepository;
import io.spring.iam.repository.ManagedResourceRepository;
import io.spring.iam.repository.PermissionRepository;
import io.spring.iam.resource.MethodPatternAnalyzer;
import io.spring.iam.resource.MethodPatternAnalyzer.MethodAnalysisResult;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AutoConditionTemplateService {

    private final ConditionTemplateRepository conditionTemplateRepository;
    private final MethodPatternAnalyzer methodPatternAnalyzer;
    private final PermissionRepository permissionRepository;
    private final ManagedResourceRepository managedResourceRepository;
    private final AINativeIAMAdvisor aiAdvisor;
    private final ObjectMapper objectMapper;

    /**
     * 메서드 시그니처 정보를 담는 클래스
     */
    public static class MethodSignature {
        public final String methodName;
        public final String parameterInfo;
        public final String resourceType;
        
        public MethodSignature(String methodName, String parameterInfo, String resourceType) {
            this.methodName = methodName;
            this.parameterInfo = parameterInfo;
            this.resourceType = resourceType;
        }
    }

    /**
     * 자동 생성된 조건 템플릿 정보를 담는 DTO
     */


    /**
     * 메서드 분석 결과를 바탕으로 조건 템플릿을 자동 생성합니다.
     */
    @Transactional
    public List<ConditionTemplate> generateTemplatesFromAnalysis(List<MethodAnalysisResult> analysisResults) {
        log.info("🔄 자동 조건 템플릿 생성 시작: {} 개 분석 결과", analysisResults.size());

        List<ConditionTemplate> generatedTemplates = new ArrayList<>();

        // 1. 범용 조건 템플릿 생성 (한 번만)
        List<ConditionTemplate> universalTemplates = generateUniversalTemplates();
        generatedTemplates.addAll(universalTemplates);

        // 2. 메서드별 특화 템플릿 생성
        for (MethodAnalysisResult analysis : analysisResults) {
            List<ConditionTemplate> methodTemplates = generateMethodSpecificTemplates(analysis);
            generatedTemplates.addAll(methodTemplates);
        }

        // 3. 중복 제거 및 DB 저장
        List<ConditionTemplate> savedTemplates = saveDedupedTemplates(generatedTemplates);

        log.info("✅ 자동 조건 템플릿 생성 완료: {} 개 템플릿 저장", savedTemplates.size());
        return savedTemplates;
    }

    /**
     * 범용 조건 템플릿들을 생성합니다. (hasPermission 방식)
     */
    private List<ConditionTemplate> generateUniversalTemplates() {
        List<AutoGeneratedTemplate> universalTemplates = Arrays.asList(
                // 시간 기반 조건들
                new AutoGeneratedTemplate(
                        "업무시간 접근",
                        "평일 오전 9시부터 오후 6시까지만 접근 허용",
                        "T(java.time.LocalTime).now().hour >= 9 and T(java.time.LocalTime).now().hour <= 18",
                        "universal", "system_generated", true),

                new AutoGeneratedTemplate(
                        "평일 접근",
                        "월요일부터 금요일까지만 접근 허용",
                        "T(java.time.LocalDate).now().dayOfWeek.value <= 5",
                        "universal", "system_generated", true),

                // IP 기반 조건들
                new AutoGeneratedTemplate(
                        "내부망 접근",
                        "192.168.x.x 대역에서만 접근 허용",
                        "#request.remoteAddr matches '^192\\\\.168\\\\..*'",
                        "universal", "system_generated", true),

                new AutoGeneratedTemplate(
                        "사내망 접근",
                        "10.x.x.x 대역에서만 접근 허용",
                        "#request.remoteAddr matches '^10\\\\..*'",
                        "universal", "system_generated", true),

                // 인증된 사용자 기반 조건들
                new AutoGeneratedTemplate(
                        "인증된 사용자",
                        "로그인한 사용자만 접근 허용",
                        "isAuthenticated()",
                        "universal", "system_generated", true),

                new AutoGeneratedTemplate(
                        "완전 인증된 사용자",
                        "완전히 인증된 사용자만 접근 허용 (Remember-me 제외)",
                        "isFullyAuthenticated()",
                        "universal", "system_generated", true)
        );

        return universalTemplates.stream()
                .map(this::convertToConditionTemplate)
                .collect(Collectors.toList());
    }

    /**
     * 특정 메서드에 대한 조건 템플릿들을 생성합니다.
     */
    private List<ConditionTemplate> generateMethodSpecificTemplates(MethodAnalysisResult analysis) {
        List<AutoGeneratedTemplate> templates = new ArrayList<>();

        switch (analysis.getDetectedPattern()) {
            case OBJECT_RETURN_PATTERN:
                templates.addAll(generateObjectReturnTemplates(analysis));
                break;
            case ID_PARAMETER_PATTERN:
                templates.addAll(generateIdParameterTemplates(analysis));
                break;
            case UNIVERSAL_PATTERN:
                // 범용 패턴은 이미 처리됨
                break;
            default:
                log.debug("지원하지 않는 패턴으로 템플릿 생성 스킵: {}", analysis.getDetectedPattern());
        }

        return templates.stream()
                .map(this::convertToConditionTemplate)
                .collect(Collectors.toList());
    }

    /**
     * 객체 반환 패턴 템플릿 생성 (hasPermission 방식)
     */
    private List<AutoGeneratedTemplate> generateObjectReturnTemplates(MethodAnalysisResult analysis) {
        String entityType = (String) analysis.getMetadata().get("entityType");
        String methodId = analysis.getMethodIdentifier();

        // 🔄 개선: 한국어 친화적인 조건명 생성
        String koreanEntityName = getKoreanEntityName(entityType);
        String methodName = extractMethodName(methodId);

        return Arrays.asList(
                new AutoGeneratedTemplate(
                        String.format("특정 %s 읽기 권한", koreanEntityName),
                        String.format("조회된 특정 %s 객체에 대한 개별 읽기 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                        "hasPermission(#returnObject, 'READ')",
                        "object_return", methodId, false),

                new AutoGeneratedTemplate(
                        String.format("특정 %s 수정 권한", koreanEntityName),
                        String.format("조회된 특정 %s 객체에 대한 개별 수정 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                        "hasPermission(#returnObject, 'UPDATE')",
                        "object_return", methodId, false),

                new AutoGeneratedTemplate(
                        String.format("특정 %s 삭제 권한", koreanEntityName),
                        String.format("조회된 특정 %s 객체에 대한 개별 삭제 권한을 확인합니다 [메서드: %s]", koreanEntityName, methodName),
                        "hasPermission(#returnObject, 'DELETE')",
                        "object_return", methodId, false)
        );
    }

    /**
     * ID 파라미터 패턴 템플릿 생성 (hasPermission 방식)
     */
    private List<AutoGeneratedTemplate> generateIdParameterTemplates(MethodAnalysisResult analysis) {
        String entityType = (String) analysis.getMetadata().get("entityType");
        String idParamName = (String) analysis.getMetadata().get("idParameterName");
        String methodId = analysis.getMethodIdentifier();

        // 🔄 개선: 한국어 친화적인 조건명 생성
        String koreanEntityName = getKoreanEntityName(entityType);
        String actionName = extractActionFromMethod(methodId);

        return Arrays.asList(
                new AutoGeneratedTemplate(
                        String.format("개별 %s %s 권한", koreanEntityName, actionName),
                        String.format("특정 ID의 %s 객체에 대한 개별 %s 권한을 확인합니다", koreanEntityName, actionName),
                        String.format("hasPermission(#%s, '%s', 'UPDATE')", idParamName, entityType.toUpperCase()),
                        "id_parameter", methodId, false),

                new AutoGeneratedTemplate(
                        String.format("개별 %s 삭제 권한", koreanEntityName),
                        String.format("특정 ID의 %s 객체에 대한 개별 삭제 권한을 확인합니다", koreanEntityName),
                        String.format("hasPermission(#%s, '%s', 'DELETE')", idParamName, entityType.toUpperCase()),
                        "id_parameter", methodId, false)
        );
    }

    /**
     * 엔티티 타입을 동적으로 한국어로 변환
     * 패턴 분석을 통해 하드코딩 없이 한국어명 생성
     */
    private String getKoreanEntityName(String entityType) {
        if (entityType == null || entityType.trim().isEmpty()) {
            return "리소스";
        }
        
        // 대소문자 정규화
        String normalizedType = entityType.trim();
        String lowerType = normalizedType.toLowerCase();
        
        // 동적 패턴 매칭을 통한 한국어 변환
        if (lowerType.contains("user")) {
            return "사용자";
        } else if (lowerType.contains("group")) {
            return "그룹";
        } else if (lowerType.contains("role")) {
            return "역할";
        } else if (lowerType.contains("permission")) {
            return "권한";
        } else if (lowerType.contains("policy")) {
            return "정책";
        } else if (lowerType.contains("document")) {
            return "문서";
        } else if (lowerType.contains("file")) {
            return "파일";
        } else if (lowerType.contains("project")) {
            return "프로젝트";
        } else if (lowerType.contains("organization") || lowerType.contains("org")) {
            return "조직";
        } else if (lowerType.contains("department") || lowerType.contains("dept")) {
            return "부서";
        } else if (lowerType.contains("team")) {
            return "팀";
        } else if (lowerType.contains("resource")) {
            return "리소스";
        } else if (lowerType.contains("data")) {
            return "데이터";
        } else if (lowerType.contains("system")) {
            return "시스템";
        } else if (lowerType.contains("service")) {
            return "서비스";
        } else {
            // 알 수 없는 타입의 경우 영어 그대로 반환하되 첫 글자만 소문자로
            return normalizedType.substring(0, 1).toLowerCase() + normalizedType.substring(1);
        }
    }

    /**
     * 메서드명에서 액션 타입을 동적으로 추출
     * 다양한 패턴을 분석하여 적절한 한국어 액션명 반환
     */
    private String extractActionFromMethod(String methodName) {
        if (methodName == null || methodName.trim().isEmpty()) {
            return "처리";
        }

        String lowerMethod = methodName.toLowerCase().trim();
        
        // 동사 패턴 분석 (시작 패턴 우선)
        if (lowerMethod.startsWith("create") || lowerMethod.startsWith("add") || 
            lowerMethod.startsWith("insert") || lowerMethod.startsWith("new") ||
            lowerMethod.startsWith("register") || lowerMethod.startsWith("build")) {
            return "생성";
        } else if (lowerMethod.startsWith("get") || lowerMethod.startsWith("find") || 
                   lowerMethod.startsWith("fetch") || lowerMethod.startsWith("retrieve") ||
                   lowerMethod.startsWith("select") || lowerMethod.startsWith("search") ||
                   lowerMethod.startsWith("load") || lowerMethod.startsWith("read") ||
                   lowerMethod.startsWith("view") || lowerMethod.startsWith("show")) {
            return "조회";
        } else if (lowerMethod.startsWith("update") || lowerMethod.startsWith("modify") || 
                   lowerMethod.startsWith("edit") || lowerMethod.startsWith("change") ||
                   lowerMethod.startsWith("alter") || lowerMethod.startsWith("set")) {
            return "수정";
        } else if (lowerMethod.startsWith("delete") || lowerMethod.startsWith("remove") || 
                   lowerMethod.startsWith("drop") || lowerMethod.startsWith("clear") ||
                   lowerMethod.startsWith("destroy") || lowerMethod.startsWith("purge")) {
            return "삭제";
        } else if (lowerMethod.startsWith("save") || lowerMethod.startsWith("store") ||
                   lowerMethod.startsWith("persist")) {
            return "저장";
        } else if (lowerMethod.startsWith("validate") || lowerMethod.startsWith("check") ||
                   lowerMethod.startsWith("verify") || lowerMethod.startsWith("confirm")) {
            return "검증";
        } else if (lowerMethod.startsWith("approve") || lowerMethod.startsWith("accept")) {
            return "승인";
        } else if (lowerMethod.startsWith("reject") || lowerMethod.startsWith("deny") ||
                   lowerMethod.startsWith("decline")) {
            return "거부";
        } else if (lowerMethod.startsWith("assign") || lowerMethod.startsWith("grant") ||
                   lowerMethod.startsWith("give") || lowerMethod.startsWith("allocate")) {
            return "할당";
        } else if (lowerMethod.startsWith("revoke") || lowerMethod.startsWith("unassign") ||
                   lowerMethod.startsWith("withdraw") || lowerMethod.startsWith("cancel")) {
            return "취소";
        } else if (lowerMethod.startsWith("send") || lowerMethod.startsWith("notify") ||
                   lowerMethod.startsWith("alert")) {
            return "전송";
        } else if (lowerMethod.startsWith("process") || lowerMethod.startsWith("handle") ||
                   lowerMethod.startsWith("execute") || lowerMethod.startsWith("run")) {
            return "처리";
        } else if (lowerMethod.startsWith("count") || lowerMethod.startsWith("calculate") ||
                   lowerMethod.startsWith("compute")) {
            return "계산";
        } else if (lowerMethod.startsWith("copy") || lowerMethod.startsWith("clone") ||
                   lowerMethod.startsWith("duplicate")) {
            return "복사";
        } else if (lowerMethod.startsWith("move") || lowerMethod.startsWith("transfer")) {
            return "이동";
        } else if (lowerMethod.startsWith("export") || lowerMethod.startsWith("download")) {
            return "내보내기";
        } else if (lowerMethod.startsWith("import") || lowerMethod.startsWith("upload")) {
            return "가져오기";
        } else {
            // 알 수 없는 패턴의 경우 기본값
            return "처리";
        }
    }

    /**
     * 메서드 ID에서 메서드명을 동적으로 추출
     * resource_identifier 형태: "io.spring.iam.admin.iam.service.impl.GroupServiceImpl.updateGroup(Group,List)"
     */
    private String extractMethodName(String methodId) {
        if (methodId == null || methodId.trim().isEmpty()) {
            return "unknown";
        }

        try {
            String trimmed = methodId.trim();
            
            // 마지막 점(.) 이후의 부분을 추출
            int lastDotIndex = trimmed.lastIndexOf('.');
            if (lastDotIndex == -1) {
                // 점이 없으면 전체가 메서드명
                return extractMethodNameFromSignature(trimmed);
            }
            
            String methodPart = trimmed.substring(lastDotIndex + 1);
            return extractMethodNameFromSignature(methodPart);
            
        } catch (Exception e) {
            log.warn("⚠️ 메서드명 추출 실패: {}", methodId, e);
            return "unknown";
        }
    }
    
    /**
     * 메서드 시그니처에서 순수 메서드명만 추출
     * 예: "updateGroup(Group,List)" -> "updateGroup"
     */
    private String extractMethodNameFromSignature(String methodSignature) {
        if (methodSignature == null || methodSignature.trim().isEmpty()) {
            return "unknown";
        }
        
        String trimmed = methodSignature.trim();
        
        // 괄호가 있으면 괄호 앞까지만 추출
        int parenIndex = trimmed.indexOf('(');
        if (parenIndex != -1) {
            return trimmed.substring(0, parenIndex).trim();
        }
        
        // 괄호가 없으면 전체가 메서드명
        return trimmed;
    }

    /**
     * 메서드 ID에서 고유한 접미사를 생성합니다.
     */
    private String generateMethodSuffix(String methodId) {
        // 메서드 ID에서 클래스명과 메서드명을 추출하여 짧은 접미사 생성
        if (methodId == null) return "AUTO";

        String[] parts = methodId.split("\\.");
        if (parts.length >= 2) {
            String className = parts[parts.length - 2];
            String methodName = parts[parts.length - 1];

            // 클래스명의 첫 글자 + 메서드명의 첫 3글자
            String classPrefix = className.length() > 0 ? className.substring(0, 1).toUpperCase() : "X";
            String methodPrefix = methodName.length() >= 3 ? methodName.substring(0, 3).toUpperCase() : methodName.toUpperCase();

            return classPrefix + methodPrefix;
        }

        // 해시 코드를 사용한 고유 접미사
        return String.valueOf(Math.abs(methodId.hashCode()) % 10000);
    }

    /**
     * AutoGeneratedTemplate을 ConditionTemplate 엔티티로 변환
     * 🔄 2단계: 자동 분류 시스템 적용
     */
    private ConditionTemplate convertToConditionTemplate(AutoGeneratedTemplate template) {
        ConditionTemplate entity = new ConditionTemplate();
        entity.setName(template.getName());
        entity.setDescription(template.getDescription());
        entity.setSpelTemplate(template.getSpelTemplate());
        entity.setIsAutoGenerated(true);
        entity.setTemplateType(template.getTemplateType());
        entity.setSourceMethod(template.getSourceMethod());
        entity.setIsUniversal(template.isUniversal());
        entity.setCreatedAt(LocalDateTime.now());
        entity.setUpdatedAt(LocalDateTime.now());

        // 🔄 2단계: 자동 생성 템플릿의 분류 결정
        if (template.isUniversal()) {
            // 범용 조건
            entity.setClassification(ConditionTemplate.ConditionClassification.UNIVERSAL);
            entity.setRiskLevel(ConditionTemplate.RiskLevel.LOW);
            entity.setComplexityScore(1);
            entity.setApprovalRequired(false);
            entity.setContextDependent(false);
        } else {
            // 템플릿 타입에 따른 분류
            switch (template.getTemplateType()) {
                case "object_return", "id_parameter", "ownership" -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.MEDIUM);
                    entity.setComplexityScore(calculateAutoTemplateComplexity(template.getSpelTemplate()));
                    entity.setApprovalRequired(false); // AI 검증만 필요
                    entity.setContextDependent(true);
                }
                case "self_check" -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.UNIVERSAL);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.LOW);
                    entity.setComplexityScore(2);
                    entity.setApprovalRequired(false);
                    entity.setContextDependent(false);
                }
                default -> {
                    entity.setClassification(ConditionTemplate.ConditionClassification.CUSTOM_COMPLEX);
                    entity.setRiskLevel(ConditionTemplate.RiskLevel.HIGH);
                    entity.setComplexityScore(calculateAutoTemplateComplexity(template.getSpelTemplate()));
                    entity.setApprovalRequired(true);
                    entity.setContextDependent(true);
                }
            }
        }

        return entity;
    }

    /**
     * 자동 생성 템플릿의 복잡도를 계산합니다.
     */
    private int calculateAutoTemplateComplexity(String spelTemplate) {
        if (spelTemplate == null) return 1;

        int score = 1;
        String spel = spelTemplate.toLowerCase();

        // hasPermission 사용 시 +2점
        if (spel.contains("haspermission")) score += 2;

        // 변수 개수에 따른 점수
        score += (spel.length() - spel.replace("#", "").length());

        // 논리 연산자
        if (spel.contains("&&") || spel.contains("||")) score += 1;

        return Math.min(score, 10);
    }

    /**
     * 🔧 개선: 중복을 제거하고 DB에 저장 (고유 이름 보장)
     * 이름과 SpEL 템플릿 모두 기준으로 중복 체크하며, 필요시 이름에 접미사 추가
     */
    @Transactional
    public List<ConditionTemplate> saveDedupedTemplates(List<ConditionTemplate> templates) {
        // 전체 기존 템플릿들 조회 (자동/수동 생성 모두)
        List<ConditionTemplate> allExistingTemplates = conditionTemplateRepository.findAll();

        // 중복 체크를 위한 Set 생성 (이름과 SpEL 템플릿 모두)
        Set<String> existingNames = allExistingTemplates.stream()
                .map(ConditionTemplate::getName)
                .collect(Collectors.toSet());

        Set<String> existingSpelTemplates = allExistingTemplates.stream()
                .map(ConditionTemplate::getSpelTemplate)
                .collect(Collectors.toSet());

        // 처리 중인 템플릿들의 이름도 추적 (배치 내에서 중복 방지)
        Set<String> processingNames = new HashSet<>();

        // 새 템플릿들을 필터링하고 중복 시 이름 수정
        List<ConditionTemplate> newTemplates = templates.stream()
                .filter(template -> {
                    // SpEL 중복 체크 (SpEL이 중복되면 완전히 제외)
                    if (existingSpelTemplates.contains(template.getSpelTemplate())) {
                        log.debug("⚠️ SpEL 중복으로 건너뜀: {} -> {}", template.getName(), template.getSpelTemplate());
                        return false;
                    }

                    // 이름 중복 체크 및 해결
                    String originalName = template.getName();
                    String uniqueName = makeUniqueName(originalName, existingNames, processingNames);

                    if (!originalName.equals(uniqueName)) {
                        log.info("🔄 이름 중복 해결: '{}' -> '{}'", originalName, uniqueName);
                        template.setName(uniqueName);
                    }

                    // 처리 중인 이름에 추가
                    processingNames.add(uniqueName);
                    existingNames.add(uniqueName); // 다음 템플릿 처리 시 고려되도록

                    return true;
                })
                .collect(Collectors.toList());

        log.info("💾 새로운 템플릿 저장: {} 개 (전체: {} 개, SpEL 중복 제외: {} 개)",
                newTemplates.size(), templates.size(), templates.size() - newTemplates.size());

        return newTemplates.isEmpty() ? new ArrayList<>() : conditionTemplateRepository.saveAll(newTemplates);
    }

    /**
     * 🔧 고유한 이름 생성 (중복 시 접미사 추가)
     */
    private String makeUniqueName(String baseName, Set<String> existingNames, Set<String> processingNames) {
        if (!existingNames.contains(baseName) && !processingNames.contains(baseName)) {
            return baseName;
        }

        // 중복 시 접미사 추가 시도
        for (int i = 2; i <= 100; i++) {
            String candidateName = baseName + " (" + i + ")";
            if (!existingNames.contains(candidateName) && !processingNames.contains(candidateName)) {
                return candidateName;
            }
        }

        // 최후 수단: 타임스탬프 추가
        String timestampName = baseName + " (" + System.currentTimeMillis() % 10000 + ")";
        log.warn("⚠️ 고유 이름 생성을 위해 타임스탬프 사용: {}", timestampName);
        return timestampName;
    }

    /**
     * 🔧 통합: 리소스와 권한을 모두 고려한 통합 조건 템플릿 생성
     */
    @Transactional
    public List<ConditionTemplate> generateConditionTemplates() {
        log.info("🎯 AI 기반 METHOD 리소스 조건 템플릿 생성 시작");

        // ABAC는 서비스 레이어에서만 체크 - METHOD 타입 리소스만 대상
        List<ManagedResource> methodResources = managedResourceRepository.findAll()
                .stream()
                .filter(resource -> resource.getResourceType() == ManagedResource.ResourceType.METHOD)
                .filter(resource -> resource.getStatus() != ManagedResource.Status.EXCLUDED)
                .collect(Collectors.toList());

        if (methodResources.isEmpty()) {
            log.warn("⚠️ METHOD 타입 리소스가 없습니다. 조건 템플릿을 생성하지 않습니다.");
            return new ArrayList<>();
        }

        log.info("📋 AI 분석 대상 METHOD 리소스: {} 개", methodResources.size());

        List<ConditionTemplate> templates = new ArrayList<>();

        // 1. 범용 조건 템플릿 (AI로 생성)
        templates.addAll(generateAIUniversalTemplates());

                // 2. METHOD 리소스별 AI 특화 조건 템플릿  
        Set<String> processedMethodSignatures = new HashSet<>();
        int processedCount = 0;
        int skippedCount = 0;
        
        for (ManagedResource resource : methodResources) {
            try {
                // 메서드 시그니처 파싱하여 고유 식별자 생성
                MethodSignature signature = parseMethodSignature(resource);
                String methodSignatureKey = signature.methodName + ":" + signature.parameterInfo + ":" + signature.resourceType;
                
                // 중복 메서드 시그니처 처리 방지
                if (processedMethodSignatures.contains(methodSignatureKey)) {
                    log.warn("⚠️ 중복 메서드 시그니처 건너뛰기: {} - {}", signature.methodName, resource.getResourceIdentifier());
                    skippedCount++;
                    continue;
                }
                
                List<ConditionTemplate> methodTemplates = generateAISpecificTemplates(resource);
                templates.addAll(methodTemplates);
                processedMethodSignatures.add(methodSignatureKey);
                processedCount++;
                
                log.info("✅ 메서드 {} 처리 완료: {} 개 조건 생성", signature.methodName, methodTemplates.size());
                
            } catch (Exception e) {
                log.warn("⚠️ AI 메서드 분석 실패: {} - {}", resource.getResourceIdentifier(), e.getMessage());
                skippedCount++;
            }
        }
        
        log.info("📊 메서드 처리 결과: 처리됨 {} 개, 건너뜀 {} 개", processedCount, skippedCount);

        // 중복 제거 및 저장
        List<ConditionTemplate> savedTemplates = saveDedupedTemplates(templates);

        log.info("🎉 AI 기반 조건 템플릿 생성 완료: {} 개", savedTemplates.size());
        return savedTemplates;
    }

    /**
     * AI를 통한 범용 조건 템플릿 생성
     */
    private List<ConditionTemplate> generateAIUniversalTemplates() {
        log.info("🤖 AI 범용 조건 템플릿 생성 시작");

        // 개선된 프롬프트 없이 바로 AINativeIAMAdvisor 호출
        String userPrompt = "서비스 레이어에서 정말 필요한 핵심 범용 조건 4-5개만 생성해주세요.";

        try {
            String aiResponse = callAI("", userPrompt);
            return parseAITemplateResponse(aiResponse, "범용");
        } catch (Exception e) {
            log.error("🔥 AI 범용 템플릿 생성 실패", e);
            return generateFallbackUniversalTemplates();
        }
    }

    /**
     * AI를 통한 특정 메서드별 조건 템플릿 생성
     */
        private List<ConditionTemplate> generateAISpecificTemplates(ManagedResource resource) {
        log.info("🤖 AI 특화 조건 생성: {}", resource.getResourceIdentifier());
        
        // 메서드 시그니처 정확히 파싱
        MethodSignature signature = parseMethodSignature(resource);
        
        // 파라미터가 없는 메서드는 건너뛰기 (동적 파싱 결과 기준)
        if (signature.parameterInfo.equals("파라미터 없음")) {
            log.info("⏭️ 파라미터 없는 메서드 건너뛰기: {} - {}", signature.methodName, resource.getResourceIdentifier());
            return new ArrayList<>();
        }
        
        // 알 수 없는 파라미터인 경우도 건너뛰기
        if (signature.parameterInfo.contains("알 수 없는 파라미터")) {
            log.info("⏭️ 알 수 없는 파라미터 메서드 건너뛰기: {} - {}", signature.methodName, resource.getResourceIdentifier());
            return new ArrayList<>();
        }
        
        // 객체 파라미터인지 ID 파라미터인지 구분
        boolean isObjectParam = signature.parameterInfo.contains("객체") || 
                               signature.parameterInfo.contains("#group") || 
                               signature.parameterInfo.contains("#userDto");
        
        String methodInfo;
        if (isObjectParam) {
            // 객체 파라미터인 경우 - 리소스 타입 정보 제공하되 hasPermission에서 사용 금지 명시
            methodInfo = String.format("""
                🚨 극도로 제한된 조건 생성 요청 🚨
                
                📋 분석 대상 메서드:
                - 서비스: %s 
                - 메서드명: %s
                - 허용된 파라미터: %s (이것만 사용 가능!)
                - 리소스 타입: %s (참고용, hasPermission에서 사용 금지!)
                
                🔒 hasPermission 사용법:
                %s
                
                🔍 메서드 컨텍스트:
                %s
                
                🚨 시스템 크래시 방지 규칙:
                1. 정확히 하나의 조건만 생성 (2개 이상 시 시스템 오류)
                2. 위에 명시된 파라미터만 사용 (다른 파라미터 시 크래시)
                3. hasPermission()은 반드시 2개 파라미터만 사용 (3개 파라미터 시 크래시)
                4. 리소스 타입을 hasPermission에 절대 사용하지 마세요! (크래시!)
                5. "~대상 검증", "~접근 확인" 용어만 사용 ("~권한" 시 크래시)
                6. hasPermission() 함수만 사용 (다른 함수 시 크래시)
                
                ❌ 시스템 크래시 유발 항목:
                - #currentUser, #user, #rootScope (절대 존재하지 않음)
                - hasPermission(#userDto, 'USER', 'UPDATE') 형식 (크래시!)
                - hasPermission(#document, 'DOCUMENT', 'CREATE') 형식 (크래시!)
                - hasPermission(#group, 'GROUP', 'UPDATE') 형식 (크래시!)
                - 여러 조건 생성
                - "권한" 용어 사용 (시스템 크래시!)
                
                ✅ 올바른 네이밍 예시:
                - "그룹 수정 대상 검증" (권한 X, 대상 검증 O)
                - "사용자 수정 대상 검증" (권한 X, 대상 검증 O)  
                - "문서 생성 대상 검증" (권한 X, 대상 검증 O)
                - "그룹 생성 접근 확인" (권한 X, 접근 확인 O)
                
                ✅ 올바른 SpEL 예시:
                - hasPermission(#document, 'CREATE') ← 2개 파라미터만!
                - hasPermission(#userDto, 'UPDATE') ← 2개 파라미터만!
                - hasPermission(#group, 'UPDATE') ← 2개 파라미터만!
                """, 
                getServiceName(signature.resourceType),
                signature.methodName,
                signature.parameterInfo,
                signature.resourceType,
                generateHasPermissionUsage(signature),
                getMethodContext(signature.methodName));
        } else {
            // ID 파라미터인 경우 - 리소스 타입 정보 제공
            methodInfo = String.format("""
                🚨 극도로 제한된 조건 생성 요청 🚨
                
                📋 분석 대상 메서드:
                - 서비스: %s 
                - 메서드명: %s
                - 허용된 파라미터: %s (이것만 사용 가능!)
                - 허용된 리소스 타입: %s (이것만 사용 가능!)
                
                🔒 hasPermission 사용법:
                %s
                
                🔍 메서드 컨텍스트:
                %s
                
                🚨 시스템 크래시 방지 규칙:
                1. 정확히 하나의 조건만 생성 (2개 이상 시 시스템 오류)
                2. 위에 명시된 파라미터만 사용 (다른 파라미터 시 크래시)
                3. 위에 명시된 리소스 타입만 사용 (다른 타입 시 크래시)
                4. hasPermission()은 반드시 3개 파라미터 사용 (2개 파라미터 시 크래시)
                5. "~대상 검증", "~접근 확인" 용어만 사용 ("~권한" 시 크래시)
                6. hasPermission() 함수만 사용 (다른 함수 시 크래시)
                
                ❌ 시스템 크래시 유발 항목:
                - #document, #currentUser, #user (절대 존재하지 않음)
                - DOCUMENT, ROLE, SYSTEM (절대 존재하지 않음)
                - hasPermission(#id, 'READ') 형식 (2개 파라미터 크래시!)
                - 여러 조건 생성
                - "권한" 용어 사용 (시스템 크래시!)
                
                ✅ 올바른 네이밍 예시:
                - "그룹 삭제 대상 검증" (권한 X, 대상 검증 O)
                - "사용자 조회 접근 확인" (권한 X, 접근 확인 O)  
                - "그룹 조회 접근 확인" (권한 X, 접근 확인 O)
                - "사용자 삭제 대상 검증" (권한 X, 대상 검증 O)
                """, 
                getServiceName(signature.resourceType),
                signature.methodName,
                signature.parameterInfo,
                signature.resourceType,
                generateHasPermissionUsage(signature),
                getMethodContext(signature.methodName));
        }
            
        try {
            String aiResponse = callAI("", methodInfo);
            List<ConditionTemplate> templates = parseAITemplateResponse(aiResponse, resource.getResourceIdentifier());
            
            // 안전장치: 하나의 조건만 반환하도록 제한
            if (templates.size() > 1) {
                log.warn("⚠️ AI가 {} 개 조건 생성했지만 첫 번째만 사용: {}", templates.size(), resource.getResourceIdentifier());
                templates = List.of(templates.get(0));
            }
            
            return templates;
        } catch (Exception e) {
            log.warn("🔥 AI 특화 템플릿 생성 실패: {}", resource.getResourceIdentifier(), e);
            return new ArrayList<>();
        }
    }

    /**
     * AI 호출 헬퍼 메서드 - AINativeIAMAdvisor를 통한 실제 AI 호출
     */
    private String callAI(String systemPrompt, String userPrompt) {
        try {
            log.info("🤖 AINativeIAMAdvisor를 통한 AI 호출 시작");

            // 범용 조건인지 특화 조건인지 구분하여 적절한 메서드 호출
            if (userPrompt.contains("범용") || userPrompt.contains("업무 환경에서 자주 사용되는")) {
                log.info("🌐 범용 조건 템플릿 생성 요청");
                log.info("📝 범용 조건 입력: {}", userPrompt);
                String response = aiAdvisor.generateUniversalConditionTemplates();
                log.info("🤖 AI 범용 응답: {}", response);
                return response;
            } else {
                log.info("🎯 특화 조건 템플릿 생성 요청");
                log.info("📝 특화 조건 입력: {}", userPrompt);
                String response = aiAdvisor.generateSpecificConditionTemplates("METHOD", userPrompt);
                log.info("🤖 AI 특화 응답: {}", response);
                return response;
            }

        } catch (Exception e) {
            log.error("🔥 AINativeIAMAdvisor 호출 실패", e);
            // 폴백 제거 - AI 실패 시 빈 응답 반환
            return "[]";
        }
    }

    // 폴백 메서드 제거됨 - AI 응답만 분석

    /**
     * AI 응답을 ConditionTemplate 객체로 파싱
     */
    private List<ConditionTemplate> parseAITemplateResponse(String aiResponse, String sourceMethod) {
        List<ConditionTemplate> templates = new ArrayList<>();

        log.info("🔍 AI 응답 파싱 시작 - 소스: {}", sourceMethod);
        log.info("📄 원본 AI 응답: {}", aiResponse);

        try {
            // JSON 정제 - 마크다운 코드 블록 제거 및 불필요한 텍스트 제거
            String cleanedJson = extractAndCleanJson(aiResponse);
            log.info("🔍 정제된 JSON: {}", cleanedJson);

            // JSON 배열 파싱 시도
            List<Map<String, Object>> rawTemplates = objectMapper.readValue(
                    cleanedJson, new TypeReference<List<Map<String, Object>>>() {});

            log.info("📊 파싱된 템플릿 개수: {} 개", rawTemplates.size());

            for (int i = 0; i < rawTemplates.size(); i++) {
                Map<String, Object> raw = rawTemplates.get(i);
                log.info("🎯 템플릿 {} 파싱: {}", i+1, raw);

                try {
                    ConditionTemplate template = ConditionTemplate.builder()
                            .name((String) raw.get("name"))
                            .description((String) raw.get("description"))
                            .spelTemplate((String) raw.get("spelTemplate"))
                            .category((String) raw.getOrDefault("category", "AI 생성"))
                            .classification(parseClassification((String) raw.get("classification")))
                            .sourceMethod(sourceMethod)
                            .isAutoGenerated(true)
                            .templateType("ai_generated")
                            .createdAt(LocalDateTime.now())
                            .build();

                    // SpEL 템플릿이 비어있지 않은 경우만 추가
                    if (template.getSpelTemplate() != null && !template.getSpelTemplate().trim().isEmpty()) {
                        templates.add(template);
                        log.info("✅ 템플릿 추가됨: {} - {}", template.getName(), template.getSpelTemplate());
                    } else {
                        log.warn("⚠️ 빈 SpEL 템플릿으로 인해 제외됨: {}", raw);
                    }
                } catch (Exception itemError) {
                    log.error("🔥 템플릿 항목 파싱 실패: {}", raw, itemError);
                }
            }

            log.info("✅ AI 응답 파싱 완료: {} 개 템플릿 최종 생성", templates.size());

        } catch (Exception e) {
            log.error("🔥 AI 응답 파싱 실패: {}", aiResponse, e);
            // 파싱 실패 시 빈 리스트 반환
        }

        return templates;
    }

    /**
     * AI 응답에서 JSON 부분만 추출하고 정제
     */
    private String extractAndCleanJson(String aiResponse) {
        if (aiResponse == null || aiResponse.trim().isEmpty()) {
            return "[]";
        }

        // 마크다운 코드 블록 제거
        String cleaned = aiResponse.replaceAll("```json\\s*", "").replaceAll("```\\s*", "");

        // JSON 배열 시작과 끝 찾기
        int startIdx = cleaned.indexOf('[');
        int endIdx = cleaned.lastIndexOf(']');

        if (startIdx != -1 && endIdx != -1 && startIdx < endIdx) {
            return cleaned.substring(startIdx, endIdx + 1).trim();
        }

        // JSON 객체 형태인 경우 배열로 감싸기
        startIdx = cleaned.indexOf('{');
        endIdx = cleaned.lastIndexOf('}');

        if (startIdx != -1 && endIdx != -1 && startIdx < endIdx) {
            String jsonObject = cleaned.substring(startIdx, endIdx + 1).trim();
            return "[" + jsonObject + "]";
        }

        // 파싱할 수 있는 JSON이 없으면 빈 배열 반환
        log.warn("🔥 AI 응답에서 유효한 JSON을 찾을 수 없음: {}", aiResponse.substring(0, Math.min(100, aiResponse.length())));
        return "[]";
    }

    private ConditionTemplate.ConditionClassification parseClassification(String classification) {
        if (classification == null) return ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT;

        try {
            return ConditionTemplate.ConditionClassification.valueOf(classification.toUpperCase());
        } catch (Exception e) {
            return ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT;
        }
    }

    /**
     * AI 실패 시 기본 범용 템플릿들
     */
    private List<ConditionTemplate> generateFallbackUniversalTemplates() {
        log.info("🔄 AI 실패로 인한 기본 범용 템플릿 생성");

        List<ConditionTemplate> templates = new ArrayList<>();

        // hasPermission 기반 권한 체크
        templates.add(ConditionTemplate.builder()
                .name("객체 읽기 권한")
                .description("메서드가 반환하는 객체에 대한 읽기 권한 확인")
                .category("권한 기반")
                .classification(ConditionTemplate.ConditionClassification.CONTEXT_DEPENDENT)
                .spelTemplate("hasPermission(#returnObject, 'READ')")
                .sourceMethod("기본")
                .isAutoGenerated(true)
                .templateType("fallback")
                .createdAt(LocalDateTime.now())
                .build());

        // Spring Security 기본 표현식
        templates.add(ConditionTemplate.builder()
                .name("인증 확인")
                .description("사용자가 인증되었는지 확인")
                .category("인증 기반")
                .classification(ConditionTemplate.ConditionClassification.UNIVERSAL)
                .spelTemplate("isAuthenticated()")
                .sourceMethod("기본")
                .isAutoGenerated(true)
                .templateType("fallback")
                .createdAt(LocalDateTime.now())
                .build());

        return templates;
    }

    private String generateFallbackUniversalResponse() {
        return """
        [
          {
            "name": "인증된 사용자 확인",
            "description": "사용자가 정상적으로 로그인되어 있는지 확인",
            "spelTemplate": "isAuthenticated()",
            "category": "인증 기반",
            "classification": "UNIVERSAL"
          },
          {
            "name": "완전 인증 확인", 
            "description": "Remember-me가 아닌 완전한 인증 확인",
            "spelTemplate": "isFullyAuthenticated()",
            "category": "인증 기반",
            "classification": "UNIVERSAL"
          },
          {
            "name": "업무시간 접근",
            "description": "오전 9시부터 오후 6시 사이에만 접근 허용",
            "spelTemplate": "T(java.time.LocalTime).now().hour >= 9 and T(java.time.LocalTime).now().hour < 18",
            "category": "시간 기반",
            "classification": "UNIVERSAL"
          },
          {
            "name": "반환 객체 읽기 권한",
            "description": "메서드가 반환하는 객체에 대한 읽기 권한",
            "spelTemplate": "hasPermission(#returnObject, 'READ')",
            "category": "권한 기반", 
            "classification": "CONTEXT_DEPENDENT"
          }
        ]
        """;
    }

    private String generateFallbackSpecificResponse(String methodInfo) {
        // 메서드 정보에서 간단한 패턴 추출
        if (methodInfo.contains("getDocument") || methodInfo.contains("Document")) {
            return """
            [
              {
                "name": "문서 조회 권한",
                "description": "특정 문서 ID에 대한 조회 권한 확인",
                "spelTemplate": "hasPermission(#id, 'DOCUMENT', 'READ')",
                "category": "권한 기반",
                "classification": "CONTEXT_DEPENDENT"
              }
            ]
            """;
        }

        return """
        [
          {
            "name": "기본 실행 권한",
            "description": "메서드 실행에 대한 기본 권한",
            "spelTemplate": "hasPermission(#id, 'RESOURCE', 'EXECUTE')",
            "category": "권한 기반", 
            "classification": "CONTEXT_DEPENDENT"
          }
        ]
        """;
    }
    
    /**
     * ManagedResource에서 resource_identifier를 동적으로 파싱하여 메서드 시그니처 정보를 추출합니다.
     * resource_identifier 형태: "io.spring.iam.admin.iam.service.impl.GroupServiceImpl.updateGroup(Group,List)"
     */
    private MethodSignature parseMethodSignature(ManagedResource resource) {
        String identifier = resource.getResourceIdentifier();
        
        log.debug("🔍 메서드 시그니처 파싱: {}", identifier);
        
        try {
            // 1. 클래스명과 메서드 부분 분리
            int lastDotIndex = identifier.lastIndexOf('.');
            if (lastDotIndex == -1) {
                throw new IllegalArgumentException("잘못된 resource_identifier 형태: " + identifier);
            }
            
            String className = identifier.substring(0, lastDotIndex);
            String methodPart = identifier.substring(lastDotIndex + 1);
            
            // 2. 메서드명과 파라미터 부분 분리
            String methodName;
            String paramTypes = "";
            
            if (methodPart.contains("(")) {
                methodName = methodPart.substring(0, methodPart.indexOf("("));
                String paramPart = methodPart.substring(methodPart.indexOf("(") + 1, methodPart.lastIndexOf(")"));
                paramTypes = paramPart.trim();
            } else {
                methodName = methodPart;
            }
            
            // 3. 리소스 타입 동적 결정 (클래스명 기반)
            String resourceType = determineResourceTypeFromClassName(className);
            
            // 4. 파라미터 정보 동적 파싱
            String parameterInfo = parseParameterInfo(methodName, paramTypes);
            
            log.debug("✅ 파싱 결과 - 메서드: {}, 파라미터: {}, 리소스타입: {}", 
                     methodName, parameterInfo, resourceType);
            
            return new MethodSignature(methodName, parameterInfo, resourceType);
            
        } catch (Exception e) {
            log.error("🔥 메서드 시그니처 파싱 실패: {}", identifier, e);
            // 폴백: 기존 방식 사용
            return new MethodSignature(
                extractMethodName(identifier), 
                "파라미터 파싱 실패", 
                "UNKNOWN"
            );
        }
    }
    
    /**
     * 클래스명으로부터 리소스 타입을 동적으로 결정
     */
    private String determineResourceTypeFromClassName(String className) {
        String simpleName = className.substring(className.lastIndexOf('.') + 1);
        
        // 서비스 클래스명 패턴 분석
        if (simpleName.contains("Group")) {
            return "GROUP";
        } else if (simpleName.contains("User")) {
            return "USER";
        } else if (simpleName.contains("Role")) {
            return "ROLE";
        } else if (simpleName.contains("Permission")) {
            return "PERMISSION";
        } else if (simpleName.contains("Document")) {
            return "DOCUMENT";
        } else if (simpleName.contains("Policy")) {
            return "POLICY";
        } else {
            // 클래스명에서 Service 제거하고 대문자로 변환
            String resourceName = simpleName.replace("Service", "").replace("Impl", "");
            return resourceName.toUpperCase();
        }
    }
    
    /**
     * 리플렉션을 사용하여 실제 메서드 시그니처로부터 동적으로 파라미터 정보를 파싱합니다.
     * resource_identifier 형태: "io.spring.iam.admin.iam.service.impl.GroupServiceImpl.updateGroup(Group,List)"
     */
    private String parseParameterInfo(String methodName, String paramTypes) {
        if (paramTypes == null || paramTypes.trim().isEmpty() || paramTypes.equals("없음") || paramTypes.equals("()")) {
            return "파라미터 없음";
        }
        
        // 파라미터 타입 문자열을 파싱하여 실제 파라미터 정보 생성
        return parseParameterTypesFromString(paramTypes);
    }
    
    /**
     * 파라미터 타입 문자열을 파싱하여 SpEL에서 사용할 수 있는 파라미터 정보로 변환
     * 예: "Group,List" -> "#group (Group 객체), #selectedRoleIds (List<Long> 타입)"
     * 예: "Long" -> "#id (Long 타입)"
     * 예: "UserDto" -> "#userDto (UserDto 객체)"
     */
    private String parseParameterTypesFromString(String paramTypes) {
        if (paramTypes == null || paramTypes.trim().isEmpty()) {
            return "파라미터 없음";
        }
        
        // 괄호 제거
        String cleanTypes = paramTypes.replaceAll("[()]", "").trim();
        if (cleanTypes.isEmpty()) {
            return "파라미터 없음";
        }
        
        // 쉼표로 분리
        String[] types = cleanTypes.split(",");
        List<String> parameterInfos = new ArrayList<>();
        
        for (int i = 0; i < types.length; i++) {
            String type = types[i].trim();
            String paramInfo = generateParameterInfo(type, i);
            parameterInfos.add(paramInfo);
        }
        
        return String.join(", ", parameterInfos);
    }
    
    /**
     * 타입명으로부터 SpEL 파라미터 정보를 생성
     */
    private String generateParameterInfo(String type, int index) {
        // 제네릭 타입 처리
        String baseType = type.contains("<") ? type.substring(0, type.indexOf("<")) : type;
        
        // 패키지명 제거 (마지막 . 이후만 사용)
        if (baseType.contains(".")) {
            baseType = baseType.substring(baseType.lastIndexOf(".") + 1);
        }
        
        // 타입에 따른 파라미터명 생성
        String paramName = generateParameterName(baseType, index);
        String typeDescription = generateTypeDescription(type);
        
        return String.format("#%s (%s)", paramName, typeDescription);
    }
    
    /**
     * 타입에 따른 파라미터명 생성 (camelCase)
     */
    private String generateParameterName(String type, int index) {
        // 제네릭 타입 처리 (List<Long> -> selectedRoleIds)
        if (type.startsWith("List<")) {
            if (type.contains("Long")) {
                return "selectedRoleIds"; // List<Long>은 보통 ID 목록
            } else if (type.contains("String")) {
                return "selectedItems";
            } else {
                return "list" + (index == 0 ? "" : index);
            }
        }
        
        switch (type) {
            // 기본 타입들
            case "Long":
            case "Integer":
            case "int":
            case "long":
                return index == 0 ? "id" : (index == 1 ? "idx" : "param" + index);
            case "String":
                return index == 0 ? "value" : "param" + index;
            case "Boolean":
            case "boolean":
                return index == 0 ? "flag" : "param" + index;
                
            // 엔티티/DTO 타입들
            case "Group":
                return "group";
            case "User":
                return "user";
            case "UserDto":
                return "userDto";
            case "UserListDto":
                return "userListDto";
            case "Role":
                return "role";
            case "Permission":
                return "permission";
            case "Document":
                return "document";
                
            // 컬렉션 타입들
            case "List":
                return "selectedRoleIds"; // 기본적으로 역할 ID 목록으로 가정
            case "Set":
                return index == 0 ? "set" : "set" + index;
            case "Map":
                return index == 0 ? "map" : "map" + index;
                
            // 기타
            default:
                // 클래스명을 camelCase로 변환
                String camelCase = type.substring(0, 1).toLowerCase() + type.substring(1);
                return camelCase;
        }
    }
    
    /**
     * 타입 설명 생성
     */
    private String generateTypeDescription(String fullType) {
        if (fullType.contains("<")) {
            // 제네릭 타입 처리: List<Long> -> List<Long> 타입
            return fullType + " 타입";
        } else {
            // 단순 타입 처리
            String baseType = fullType.contains(".") ? 
                fullType.substring(fullType.lastIndexOf(".") + 1) : fullType;
            
            // 기본 타입인지 객체 타입인지 구분
            switch (baseType) {
                case "Long":
                case "Integer":
                case "String":
                case "Boolean":
                case "int":
                case "long":
                case "boolean":
                    return baseType + " 타입";
                default:
                    return baseType + " 객체";
            }
        }
    }
    
    /**
     * 리소스 타입에 따른 서비스명 동적 생성
     */
    private String getServiceName(String resourceType) {
        if (resourceType == null || resourceType.equals("UNKNOWN")) {
            return "Unknown Service";
        }
        
        // 리소스 타입을 기반으로 서비스명 생성
        String serviceName = resourceType.toLowerCase();
        serviceName = serviceName.substring(0, 1).toUpperCase() + serviceName.substring(1);
        return serviceName + "Service";
    }
    
    /**
     * 메서드명과 파라미터 정보를 기반으로 동적 컨텍스트 생성
     */
    private String getMethodContext(String methodName) {
        if (methodName == null) {
            return "메서드 정보가 없습니다.";
        }
        
        // 메서드명 패턴 분석을 통한 동적 컨텍스트 생성
        String action = determineMethodAction(methodName);
        String entity = determineMethodEntity(methodName);
        
        return String.format("%s %s 메서드입니다.", entity, action);
    }
    
    /**
     * 메서드명으로부터 액션 결정
     */
    private String determineMethodAction(String methodName) {
        String lowerName = methodName.toLowerCase();
        
        if (lowerName.startsWith("create") || lowerName.startsWith("add") || lowerName.startsWith("insert")) {
            return "생성하는";
        } else if (lowerName.startsWith("get") || lowerName.startsWith("find") || lowerName.startsWith("select") || lowerName.startsWith("retrieve")) {
            return "조회하는";
        } else if (lowerName.startsWith("update") || lowerName.startsWith("modify") || lowerName.startsWith("edit")) {
            return "수정하는";
        } else if (lowerName.startsWith("delete") || lowerName.startsWith("remove")) {
            return "삭제하는";
        } else if (lowerName.startsWith("save")) {
            return "저장하는";
        } else if (lowerName.startsWith("validate") || lowerName.startsWith("check")) {
            return "검증하는";
        } else {
            return "처리하는";
        }
    }
    
    /**
     * 메서드명으로부터 엔티티 결정
     */
    private String determineMethodEntity(String methodName) {
        String lowerName = methodName.toLowerCase();
        
        if (lowerName.contains("group")) {
            return "그룹을";
        } else if (lowerName.contains("user")) {
            return "사용자를";
        } else if (lowerName.contains("role")) {
            return "역할을";
        } else if (lowerName.contains("permission")) {
            return "권한을";
        } else if (lowerName.contains("document")) {
            return "문서를";
        } else if (lowerName.contains("policy")) {
            return "정책을";
        } else {
                         return "리소스를";
         }
     }
     
     /**
      * 메서드 시그니처에 따른 올바른 hasPermission 사용법 생성
      */
     private String generateHasPermissionUsage(MethodSignature signature) {
         // 파라미터 분석
         String paramInfo = signature.parameterInfo.toLowerCase();
         
         if (paramInfo.contains("#id (long") || paramInfo.contains("#idx (long")) {
             // ID 파라미터인 경우 - 3개 파라미터 형식
             String paramName = paramInfo.contains("#idx") ? "#idx" : "#id";
             return String.format("✅ 올바른 형식: hasPermission(%s, '%s', 'DELETE') - ID는 반드시 3개 파라미터", 
                                paramName, signature.resourceType);
         } else if (paramInfo.contains("객체") || paramInfo.contains("#group") || paramInfo.contains("#userDto")) {
             // 객체 파라미터인 경우 - 2개 파라미터 형식
             String paramName = extractParamName(signature.parameterInfo);
             return String.format("✅ 올바른 형식: hasPermission(%s, 'UPDATE') - 객체는 반드시 2개 파라미터만! 리소스 타입 사용 금지!", paramName);
         } else if (paramInfo.contains("#selectedRoleIds")) {
             // List 파라미터는 보통 사용하지 않음
             return "⚠️ List 파라미터는 hasPermission에서 직접 사용하지 않음";
         } else {
             return "hasPermission() 형식을 정확히 사용하세요";
         }
     }
     
     /**
      * 파라미터 정보에서 파라미터명 추출
      */
     private String extractParamName(String parameterInfo) {
         if (parameterInfo.contains("#group")) {
             return "#group";
         } else if (parameterInfo.contains("#userDto")) {
             return "#userDto";
         } else if (parameterInfo.contains("#id")) {
             return "#id";
         } else if (parameterInfo.contains("#idx")) {
             return "#idx";
         } else {
             return "#param";
         }
     }
}